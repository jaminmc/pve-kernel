diff -u a/security/apparmor/Kconfig b/security/apparmor/Kconfig
--- a/security/apparmor/Kconfig	2025-10-03 07:37:49.882335169 +0000
+++ b/security/apparmor/Kconfig	2025-10-03 07:27:33.793849263 +0000
@@ -59,7 +59,8 @@
 config SECURITY_APPARMOR_HASH
 	bool "Enable introspection of sha256 hashes for loaded profiles"
 	depends on SECURITY_APPARMOR_INTROSPECT_POLICY
-	select CRYPTO_LIB_SHA256
+	select CRYPTO
+	select CRYPTO_SHA256
 	default y
 	help
 	  This option selects whether introspection of loaded policy
diff -u a/security/apparmor/Makefile b/security/apparmor/Makefile
--- a/security/apparmor/Makefile	2025-09-29 17:33:37.039574746 +0000
+++ b/security/apparmor/Makefile	2025-10-03 07:27:33.793849263 +0000
@@ -28,7 +28,7 @@
 # to
 #    #define AA_SFS_AF_MASK "local inet"
 quiet_cmd_make-af = GEN     $@
-cmd_make-af = echo "static const char *const address_family_names[] = {" > $@ ;\
+cmd_make-af = echo "static const char *address_family_names[] = {" > $@ ;\
 	sed $< >>$@ -r -n -e "/AF_MAX/d" -e "/AF_LOCAL/d" -e "/AF_ROUTE/d" -e \
 	 's/^\#define[ \t]+AF_([A-Z0-9_]+)[ \t]+([0-9]+)(.*)/[\2] = "\L\1",/p';\
 	echo "};" >> $@ ;\
@@ -43,7 +43,7 @@
 # to
 #    [1] = "stream",
 quiet_cmd_make-sock = GEN     $@
-cmd_make-sock = echo "static const char *const sock_type_names[] = {" >> $@ ;\
+cmd_make-sock = echo "static const char *sock_type_names[] = {" >> $@ ;\
 	sed $^ >>$@ -r -n \
 	-e 's/^\tSOCK_([A-Z0-9_]+)[\t]+=[ \t]+([0-9]+)(.*)/[\2] = "\L\1",/p';\
 	echo "};" >> $@
diff -u a/security/apparmor/af_inet.c b/security/apparmor/af_inet.c
--- a/security/apparmor/af_inet.c	2025-09-29 17:33:37.039574746 +0000
+++ b/security/apparmor/af_inet.c	2025-10-03 07:27:33.793849263 +0000
@@ -627,7 +627,7 @@
 	struct aa_label *label;						\
 	struct aa_sk_ctx *ctx= aa_sock(SOCKSK);				\
 	int __ERROR = 0;						\
-	if (rcu_access_pointer(ctx->label) != kernel_t) {		\
+	if (ctx->label != kernel_t) {					\
 									\
 		label = begin_current_label_crit_section();		\
                 __ERROR = label_sk_has_perm2(current_cred(), label, SOCKSK, OP, REQUEST, PROFILE, AAD, XXXXY, YYYYX, CALLBACKFN); \
@@ -776,7 +776,7 @@
 	struct aa_label *label;
 	int error;
 
-	if (rcu_access_pointer(ctx->label) == kernel_t)
+	if (ctx->label == kernel_t)
 		return 0;
 
 	label = begin_current_label_crit_section();
diff -u a/security/apparmor/af_unix.c b/security/apparmor/af_unix.c
--- a/security/apparmor/af_unix.c	2025-09-29 17:33:37.039574746 +0000
+++ b/security/apparmor/af_unix.c	2025-10-03 07:27:33.793849263 +0000
@@ -31,10 +31,11 @@
 }
 
 static int unix_fs_perm(const char *op, u32 mask, const struct cred *subj_cred,
-			struct aa_label *label, struct path *path)
+			struct aa_label *label, struct unix_sock *u)
 {
 	AA_BUG(!label);
-	AA_BUG(!path);
+	AA_BUG(!u);
+	AA_BUG(!is_unix_fs(aa_unix_sk(u)));
 
 	if (unconfined(label) || !label_mediates(label, AA_CLASS_FILE))
 		return 0;
@@ -43,16 +44,16 @@
 	/* if !u->path.dentry socket is being shutdown - implicit delegation
 	 * until obj delegation is supported
 	 */
-	if (path->dentry) {
+	if (u->path.dentry) {
 		/* the sunpath may not be valid for this ns so use the path */
-		struct inode *inode = path->dentry->d_inode;
-		vfsuid_t vfsuid = i_uid_into_vfsuid(mnt_idmap(path->mnt), inode);
+		struct inode *inode = u->path.dentry->d_inode;
+		vfsuid_t vfsuid = i_uid_into_vfsuid(mnt_idmap(u->path.mnt), inode);
 		struct path_cond cond = {
 			.uid = vfsuid_into_kuid(vfsuid),
 			.mode = inode->i_mode,
 		};
 
-		return aa_path_perm(op, subj_cred, label, path,
+		return aa_path_perm(op, subj_cred, label, &u->path,
 				    PATH_SOCK_COND, mask, &cond, NULL);
 	} /* else implicitly delegated */
 
@@ -105,27 +106,18 @@
 	return state;
 }
 
-struct sockaddr_un *aa_sunaddr(const struct unix_sock *u, int *addrlen)
-{
-	struct unix_address *addr;
-
-	/* memory barrier is sufficient see note in net/unix/af_unix.c */
-	addr = smp_load_acquire(&u->addr);
-	if (addr) {
-		*addrlen = addr->len;
-		return addr->name;
-	}
-	*addrlen = 0;
-	return NULL;
-}
-
 static aa_state_t match_to_sk(struct aa_policydb *policy,
 			      aa_state_t state, u32 request,
 			      struct unix_sock *u, struct aa_perms **p,
 			      const char **info)
 {
-	int addrlen;
-	struct sockaddr_un *addr = aa_sunaddr(u, &addrlen);
+	struct sockaddr_un *addr = NULL;
+	int addrlen = 0;
+
+	if (u->addr) {
+		addr = u->addr->name;
+		addrlen = u->addr->len;
+	}
 
 	return match_to_local(policy, state, request, u->sk.sk_type,
 			      u->sk.sk_protocol, addr, addrlen, p, info);
@@ -224,7 +216,7 @@
 
 static int profile_sk_perm(struct aa_profile *profile,
 			   struct apparmor_audit_data *ad,
-			   u32 request, struct sock *sk, struct path *path)
+			   u32 request, struct sock *sk)
 {
 	struct aa_ruleset *rules = profile->label.rules[0];
 	struct aa_perms *p = NULL;
@@ -232,15 +224,11 @@
 
 	AA_BUG(!profile);
 	AA_BUG(!sk);
+	AA_BUG(is_unix_fs(sk));
 	AA_BUG(profile_unconfined(profile));
 
 	state = RULE_MEDIATES_UNIX(rules);
 	if (state) {
-		if (is_unix_fs(sk))
-			return unix_fs_perm(ad->op, request, ad->subj_cred,
-					    &profile->label,
-					    &unix_sk(sk)->path);
-
 		state = match_to_sk(rules->policy, state, request, unix_sk(sk),
 				    &p, &ad->info);
 
@@ -265,9 +253,6 @@
 
 	state = RULE_MEDIATES_UNIX(rules);
 	if (state) {
-		if (is_unix_addr_fs(ad->net.addr, ad->net.addrlen))
-			/* under v7-9 fs hook handles bind */
-			return 0;
 		/* bind for abstract socket */
 		state = match_to_local(rules->policy, state, AA_MAY_BIND,
 				       sk->sk_type, sk->sk_protocol,
@@ -291,6 +276,7 @@
 
 	AA_BUG(!profile);
 	AA_BUG(!sk);
+	AA_BUG(is_unix_fs(sk));
 	AA_BUG(!ad);
 	AA_BUG(profile_unconfined(profile));
 
@@ -298,11 +284,6 @@
 	if (state) {
 		__be16 b = cpu_to_be16(backlog);
 
-		if (is_unix_fs(sk))
-			return unix_fs_perm(ad->op, AA_MAY_LISTEN,
-					    ad->subj_cred, &profile->label,
-					    &unix_sk(sk)->path);
-
 		state = match_to_cmd(rules->policy, state, AA_MAY_LISTEN,
 				     unix_sk(sk), CMD_LISTEN, &p, &ad->info);
 		if (state && !p) {
@@ -328,16 +309,12 @@
 
 	AA_BUG(!profile);
 	AA_BUG(!sk);
+	AA_BUG(is_unix_fs(sk));
 	AA_BUG(!ad);
 	AA_BUG(profile_unconfined(profile));
 
 	state = RULE_MEDIATES_UNIX(rules);
 	if (state) {
-		if (is_unix_fs(sk))
-			return unix_fs_perm(ad->op, AA_MAY_ACCEPT,
-					    ad->subj_cred, &profile->label,
-					    &unix_sk(sk)->path);
-
 		state = match_to_sk(rules->policy, state, AA_MAY_ACCEPT,
 				    unix_sk(sk), &p, &ad->info);
 
@@ -358,16 +335,13 @@
 
 	AA_BUG(!profile);
 	AA_BUG(!sk);
+	AA_BUG(is_unix_fs(sk));
 	AA_BUG(!ad);
 	AA_BUG(profile_unconfined(profile));
 
 	state = RULE_MEDIATES_UNIX(rules);
 	if (state) {
 		__be16 b = cpu_to_be16(optname);
-		if (is_unix_fs(sk))
-			return unix_fs_perm(ad->op, request,
-					    ad->subj_cred, &profile->label,
-					    &unix_sk(sk)->path);
 
 		state = match_to_cmd(rules->policy, state, request, unix_sk(sk),
 				     CMD_OPT, &p, &ad->info);
@@ -386,9 +360,7 @@
 
 /* null peer_label is allowed, in which case the peer_sk label is used */
 static int profile_peer_perm(struct aa_profile *profile, u32 request,
-			     struct sock *sk, struct path *path,
-			     struct sockaddr_un *peer_addr,
-			     int peer_addrlen, struct path *peer_path,
+			     struct sock *sk, struct sock *peer_sk,
 			     struct aa_label *peer_label,
 			     struct apparmor_audit_data *ad)
 {
@@ -399,22 +371,26 @@
 	AA_BUG(!profile);
 	AA_BUG(profile_unconfined(profile));
 	AA_BUG(!sk);
-	AA_BUG(!peer_label);
+	AA_BUG(!peer_sk);
 	AA_BUG(!ad);
+	AA_BUG(is_unix_fs(peer_sk)); /* currently always calls unix_fs_perm */
 
 	state = RULE_MEDIATES_UNIX(rules);
 	if (state) {
+		struct aa_sk_ctx *peer_ctx = aa_sock(peer_sk);
 		struct aa_profile *peerp;
+		struct sockaddr_un *addr = NULL;
+		int len = 0;
 
-		if (peer_path)
-			return unix_fs_perm(ad->op, request, ad->subj_cred,
-					    &profile->label, peer_path);
-		else if (path)
-			return unix_fs_perm(ad->op, request, ad->subj_cred,
-					    &profile->label, path);
+		if (unix_sk(peer_sk)->addr) {
+			addr = unix_sk(peer_sk)->addr->name;
+			len = unix_sk(peer_sk)->addr->len;
+		}
 		state = match_to_peer(rules->policy, state, request,
 				      unix_sk(sk),
-				      peer_addr, peer_addrlen, &p, &ad->info);
+				      addr, len, &p, &ad->info);
+		if (!peer_label)
+			peer_label = peer_ctx->label;
 
 		return fn_for_each_in_ns(peer_label, peerp,
 				match_label(profile, rules, state, request,
@@ -442,22 +418,33 @@
 	return 0;
 }
 
-static int aa_unix_label_sk_perm(const struct cred *subj_cred,
-				 struct aa_label *label,
-				 const char *op, u32 request, struct sock *sk,
-				 struct path *path)
+int aa_unix_label_sk_perm(const struct cred *subj_cred,
+			  struct aa_label *label, const char *op, u32 request,
+			  struct sock *sk)
 {
 	if (!unconfined(label)) {
 		struct aa_profile *profile;
 		DEFINE_AUDIT_SK(ad, op, subj_cred, sk);
 
 		return fn_for_each_confined(label, profile,
-				profile_sk_perm(profile, &ad, request, sk,
-						path));
+				profile_sk_perm(profile, &ad, request, sk));
 	}
 	return 0;
 }
 
+static int unix_label_sock_perm(const struct cred *subj_cred,
+				struct aa_label *label, const char *op,
+				u32 request, struct socket *sock)
+{
+	if (unconfined(label))
+		return 0;
+	if (is_unix_fs(sock->sk))
+		return unix_fs_perm(op, request, subj_cred, label,
+				    unix_sk(sock->sk));
+
+	return aa_unix_label_sk_perm(subj_cred, label, op, request, sock->sk);
+}
+
 /* revalidation, get/set attr, shutdown */
 int aa_unix_sock_perm(const char *op, u32 request, struct socket *sock)
 {
@@ -465,9 +452,7 @@
 	int error;
 
 	label = begin_current_label_crit_section();
-	error = aa_unix_label_sk_perm(current_cred(), label, op,
-				      request, sock->sk,
-				      is_unix_fs(sock->sk) ? &unix_sk(sock->sk)->path : NULL);
+	error = unix_label_sock_perm(current_cred(), label, op, request, sock);
 	end_current_label_crit_section(label);
 
 	return error;
@@ -475,7 +460,7 @@
 
 static int valid_addr(struct sockaddr *addr, int addr_len)
 {
-	struct sockaddr_un *sunaddr = unix_addr(addr);
+	struct sockaddr_un *sunaddr = (struct sockaddr_un *)addr;
 
 	/* addr_len == offsetof(struct sockaddr_un, sun_path) is autobind */
 	if (addr_len < offsetof(struct sockaddr_un, sun_path) ||
@@ -497,7 +482,7 @@
 
 	label = begin_current_label_crit_section();
 	/* fs bind is handled by mknod */
-	if (!unconfined(label)) {
+	if (!(unconfined(label) || is_unix_addr_fs(addr, addrlen))) {
 		DEFINE_AUDIT_SK(ad, OP_BIND, current_cred(), sock->sk);
 
 		ad.net.addr = unix_addr(addr);
@@ -531,7 +516,7 @@
 	int error = 0;
 
 	label = begin_current_label_crit_section();
-	if (!unconfined(label)) {
+	if (!(unconfined(label) || is_unix_fs(sock->sk))) {
 		DEFINE_AUDIT_SK(ad, OP_LISTEN, current_cred(), sock->sk);
 
 		error = fn_for_each_confined(label, profile,
@@ -552,7 +537,7 @@
 	int error = 0;
 
 	label = begin_current_label_crit_section();
-	if (!unconfined(label)) {
+	if (!(unconfined(label) || is_unix_fs(sock->sk))) {
 		DEFINE_AUDIT_SK(ad, OP_ACCEPT, current_cred(), sock->sk);
 
 		error = fn_for_each_confined(label, profile,
@@ -585,36 +570,18 @@
 	int error = 0;
 
 	label = begin_current_label_crit_section();
-	if (!unconfined(label)) {
+	if (!(unconfined(label) || is_unix_fs(sock->sk))) {
 		DEFINE_AUDIT_SK(ad, op, current_cred(), sock->sk);
 
 		error = fn_for_each_confined(label, profile,
-				profile_opt_perm(profile, request, sock->sk,
-						 optname, &ad));
+					     profile_opt_perm(profile, request,
+						 sock->sk, optname, &ad));
 	}
 	end_current_label_crit_section(label);
 
 	return error;
 }
 
-static int unix_peer_perm(const struct cred *subj_cred,
-			  struct aa_label *label, const char *op, u32 request,
-			  struct sock *sk, struct path *path,
-			  struct sockaddr_un *peer_addr, int peer_addrlen,
-			  struct path *peer_path, struct aa_label *peer_label)
-{
-	struct aa_profile *profile;
-	DEFINE_AUDIT_SK(ad, op, subj_cred, sk);
-
-	ad.net.peer.addr = peer_addr;
-	ad.net.peer.addrlen = peer_addrlen;
-
-	return fn_for_each_confined(label, profile,
-			profile_peer_perm(profile, request, sk, path,
-					  peer_addr, peer_addrlen, peer_path,
-					  peer_label, &ad));
-}
-
 /**
  *
  * Requires: lock held on both @sk and @peer_sk
@@ -627,95 +594,62 @@
 {
 	struct unix_sock *peeru = unix_sk(peer_sk);
 	struct unix_sock *u = unix_sk(sk);
-	int plen;
-	struct sockaddr_un *paddr = aa_sunaddr(unix_sk(peer_sk), &plen);
 
 	AA_BUG(!label);
 	AA_BUG(!sk);
 	AA_BUG(!peer_sk);
-	AA_BUG(!peer_label);
 
-	return unix_peer_perm(subj_cred, label, op, request, sk,
-			      is_unix_fs(sk) ? &u->path : NULL,
-			      paddr, plen,
-			      is_unix_fs(peer_sk) ? &peeru->path : NULL,
-			      peer_label);
-}
-
-/* sk_plabel for comparison only */
-static void update_sk_ctx(struct sock *sk, struct aa_label *label,
-			  struct aa_label *plabel)
-{
-	struct aa_label *l, *old;
-	struct aa_sk_ctx *ctx = aa_sock(sk);
-	bool update_sk;
-
-	rcu_read_lock();
-	update_sk = (plabel &&
-		     (plabel != rcu_access_pointer(ctx->peer_lastupdate) ||
-		      !aa_label_is_subset(plabel, rcu_dereference(ctx->peer)))) ||
-	  !__aa_subj_label_is_cached(label, rcu_dereference(ctx->label));
-	rcu_read_unlock();
-	if (!update_sk)
+	if (is_unix_fs(aa_unix_sk(peeru))) {
+		return unix_fs_perm(op, request, subj_cred, label, peeru);
+	} else if (is_unix_fs(aa_unix_sk(u))) {
+		return unix_fs_perm(op, request, subj_cred, label, u);
+	} else if (!unconfined(label)) {
+		struct aa_profile *profile;
+		DEFINE_AUDIT_SK(ad, op, subj_cred, sk);
+
+		ad.net.peer_sk = peer_sk;
+
+		return fn_for_each_confined(label, profile,
+				profile_peer_perm(profile, request, sk,
+						  peer_sk, peer_label, &ad));
+	}
+
+	return 0;
+}
+
+static void unix_state_double_lock(struct sock *sk1, struct sock *sk2)
+{
+	if (unlikely(sk1 == sk2) || !sk2) {
+		unix_state_lock(sk1);
 		return;
+	}
+	if (sk1 < sk2) {
+		unix_state_lock(sk1);
+		unix_state_lock(sk2);
+	} else {
+		unix_state_lock(sk2);
+		unix_state_lock(sk1);
+	}
+}
 
-	spin_lock(&unix_sk(sk)->lock);
-	old = rcu_dereference_protected(ctx->label,
-					lockdep_is_held(&unix_sk(sk)->lock));
-	l = aa_label_merge(old, label, GFP_ATOMIC);
-	if (l) {
-		if (l != old) {
-			rcu_assign_pointer(ctx->label, l);
-			aa_put_label(old);
-		} else
-			aa_put_label(l);
-	}
-	if (plabel && rcu_access_pointer(ctx->peer_lastupdate) != plabel) {
-		old = rcu_dereference_protected(ctx->peer, lockdep_is_held(&unix_sk(sk)->lock));
-
-		if (old == plabel) {
-			rcu_assign_pointer(ctx->peer_lastupdate, plabel);
-		} else if (aa_label_is_subset(plabel, old)) {
-			rcu_assign_pointer(ctx->peer_lastupdate, plabel);
-			rcu_assign_pointer(ctx->peer, aa_get_label(plabel));
-			aa_put_label(old);
-		} /* else race or a subset - don't update */
-	}
-	spin_unlock(&unix_sk(sk)->lock);
-}
-
-static void update_peer_ctx(struct sock *sk, struct aa_sk_ctx *ctx,
-			    struct aa_label *label)
-{
-	struct aa_label *l, *old;
-
-	spin_lock(&unix_sk(sk)->lock);
-	old = rcu_dereference_protected(ctx->peer,
-					lockdep_is_held(&unix_sk(sk)->lock));
-	l = aa_label_merge(old, label, GFP_ATOMIC);
-	if (l) {
-		if (l != old) {
-			rcu_assign_pointer(ctx->peer, l);
-			aa_put_label(old);
-		} else
-			aa_put_label(l);
+static void unix_state_double_unlock(struct sock *sk1, struct sock *sk2)
+{
+	if (unlikely(sk1 == sk2) || !sk2) {
+		unix_state_unlock(sk1);
+		return;
 	}
-	spin_unlock(&unix_sk(sk)->lock);
+	unix_state_unlock(sk1);
+	unix_state_unlock(sk2);
 }
 
-/* This fn is only checked if something has changed in the security
- * boundaries. Otherwise cached info off file is sufficient
- */
+/* TODO: examine replacing double lock with cached addr */
+
 int aa_unix_file_perm(const struct cred *subj_cred, struct aa_label *label,
 		      const char *op, u32 request, struct file *file)
 {
 	struct socket *sock = (struct socket *) file->private_data;
-	struct sockaddr_un *addr, *peer_addr;
-	int addrlen, peer_addrlen;
-	struct aa_label *plabel = NULL;
 	struct sock *peer_sk = NULL;
 	u32 sk_req = request & ~NET_PEER_MASK;
-	struct path path;
 	bool is_sk_fs;
 	int error = 0;
 
@@ -724,76 +658,41 @@
 	AA_BUG(!sock->sk);
 	AA_BUG(sock->sk->sk_family != PF_UNIX);
 
-	/* investigate only using lock via unix_peer_get()
-	 * addr only needs the memory barrier, but need to investigate
-	 * path
-	 */
+	/* TODO: update sock label with new task label */
 	unix_state_lock(sock->sk);
 	peer_sk = unix_peer(sock->sk);
 	if (peer_sk)
 		sock_hold(peer_sk);
 
 	is_sk_fs = is_unix_fs(sock->sk);
-	addr = aa_sunaddr(unix_sk(sock->sk), &addrlen);
-	path = unix_sk(sock->sk)->path;
-	unix_state_unlock(sock->sk);
-
 	if (is_sk_fs && peer_sk)
 		sk_req = request;
-	if (sk_req) {
-			error = aa_unix_label_sk_perm(subj_cred, label, op,
-						      sk_req, sock->sk,
-						      is_sk_fs ? &path : NULL);
-	}
+	if (sk_req)
+		error = unix_label_sock_perm(subj_cred, label, op, sk_req,
+					     sock);
+	unix_state_unlock(sock->sk);
 	if (!peer_sk)
-		goto out;
-
-	peer_addr = aa_sunaddr(unix_sk(peer_sk), &peer_addrlen);
-
-	struct path peer_path;
+		return error;
 
-	peer_path = unix_sk(peer_sk)->path;
+	unix_state_double_lock(sock->sk, peer_sk);
 	if (!is_sk_fs && is_unix_fs(peer_sk)) {
 		last_error(error,
 			   unix_fs_perm(op, request, subj_cred, label,
-					is_unix_fs(peer_sk) ? &peer_path : NULL));
+					unix_sk(peer_sk)));
 	} else if (!is_sk_fs) {
-		struct aa_label *plabel;
 		struct aa_sk_ctx *pctx = aa_sock(peer_sk);
 
-		rcu_read_lock();
-		plabel = aa_get_label_rcu(&pctx->label);
-		rcu_read_unlock();
-		/* no fs check of aa_unix_peer_perm because conditions above
-		 * ensure they will never be done
-		 */
 		last_error(error,
-			xcheck(unix_peer_perm(subj_cred, label, op,
-					      MAY_READ | MAY_WRITE, sock->sk,
-					      is_sk_fs ? &path : NULL,
-					      peer_addr, peer_addrlen,
-					      is_unix_fs(peer_sk) ?
-							&peer_path : NULL,
-					      plabel),
-			       unix_peer_perm(file->f_cred, plabel, op,
-					      MAY_READ | MAY_WRITE, peer_sk,
-					      is_unix_fs(peer_sk) ?
-							&peer_path : NULL,
-					      addr, addrlen,
-					      is_sk_fs ? &path : NULL,
-					      label)));
-		if (!error && !__aa_subj_label_is_cached(plabel, label))
-			update_peer_ctx(peer_sk, pctx, label);
+			xcheck(aa_unix_peer_perm(subj_cred, label, op,
+						 MAY_READ | MAY_WRITE,
+						 sock->sk, peer_sk, NULL),
+			       aa_unix_peer_perm(file->f_cred, pctx->label, op,
+						 MAY_READ | MAY_WRITE,
+						 peer_sk, sock->sk, label)));
 	}
-	sock_put(peer_sk);
+	unix_state_double_unlock(sock->sk, peer_sk);
 
-out:
-
-	/* update peer cache to latest successful perm check */
-	if (error == 0)
-		update_sk_ctx(sock->sk, label, plabel);
-	aa_put_label(plabel);
+	sock_put(peer_sk);
 
 	return error;
 }
-
diff -u a/security/apparmor/apparmorfs.c b/security/apparmor/apparmorfs.c
--- a/security/apparmor/apparmorfs.c	2025-09-29 17:33:37.039574746 +0000
+++ b/security/apparmor/apparmorfs.c	2025-10-03 07:27:33.793849263 +0000
@@ -285,7 +285,7 @@
 	dir = d_inode(parent);
 
 	inode_lock(dir);
-	dentry = lookup_noperm(&QSTR(name), parent);
+	dentry = lookup_one_len(name, parent, strlen(name));
 	if (IS_ERR(dentry)) {
 		error = PTR_ERR(dentry);
 		goto fail_lock;
@@ -615,49 +615,34 @@
 /* file hook fn for notificaions of policy actions */
 static int listener_release(struct inode *inode, struct file *file)
 {
-	struct aa_listener_proxy *proxy = file->private_data;
+	struct aa_listener *listener = file->private_data;
 
 	if (!aa_current_policy_admin_capable(NULL))
 		return -EPERM;
-	AA_DEBUG(DEBUG_UPCALL, "file %p, listener %p, id %llu", file, proxy->listener, proxy->listener->listener_id);
-	if (proxy) {
-		AA_DEBUG(DEBUG_UPCALL, "file putting proxy");
-		aa_delayed_free_listener_proxy(proxy);
-	}
+	if (listener)
+		aa_put_listener(listener);
+
 	return 0;
 }
 
 static int listener_open(struct inode *inode, struct file *file)
 {
-	struct aa_listener_proxy *proxy;
 	struct aa_listener *listener;
-	struct aa_ns *ns = NULL;
 
 	if (!aa_current_policy_admin_capable(NULL))
 		return -EPERM;
 	listener = aa_new_listener(NULL, GFP_KERNEL);
 	if (!listener)
 		return -ENOMEM;
-	proxy = aa_new_listener_proxy(listener, ns);
-	aa_put_listener(listener);
-	if (!proxy)
-		return -ENOMEM;
-	AA_DEBUG(DEBUG_UPCALL, "Registered listener using protocol version %d",
-		 listener->version);
-	file->private_data = proxy;
+	file->private_data = listener;
 	return 0;
 }
 
-static bool notif_supported_version(struct apparmor_notif_common *unotif)
-{
-	return (unotif->version == 3 || unotif->version == 5);
-}
-
 /* todo: separate register and set filter */
 static long notify_set_filter(struct aa_listener *listener,
 			      unsigned long arg)
 {
-	union apparmor_notif_filters *unotif;
+	struct apparmor_notif_filter *unotif;
 	struct aa_ns *ns = NULL;
 	long ret;
 	u16 size;
@@ -678,13 +663,6 @@
 	}
 	ret = size;
 
-	if (!notif_supported_version((struct apparmor_notif_common *)unotif)) {
-		AA_DEBUG(DEBUG_UPCALL, "Failed to Register listener using unsupported protocol version %d", unotif->base.version);
-		ret = -EPROTONOSUPPORT;
-		goto out;
-	}
-
-	listener->version = unotif->base.version;
 	/* todo validate to known modes */
 	listener->mask = unotif->modeset;
 	AA_DEBUG(DEBUG_UPCALL, "setting filter mask to 0x%x", listener->mask);
@@ -709,6 +687,8 @@
 		}
 		listener->filter = dfa;
 	}
+	if (!aa_register_listener_proxy(listener, ns))
+		ret = -ENOMEM;
 
 out:
 	kfree(unotif);
@@ -720,25 +700,13 @@
 static long notify_user_recv(struct aa_listener *listener,
 			     unsigned long arg)
 {
-	struct apparmor_notif_common common;
+	u16 max_size;
 	void __user *buf = (void __user *)arg;
-	__u16 version;
 
-	if (copy_from_user(&common.len, buf, sizeof(common.len)))
+	if (copy_from_user(&max_size, buf, sizeof(max_size)))
 		return -EFAULT;
-	if (listener->version >= 5) {
-		/* allow individual messages to specify version */
-		if (common.len < sizeof(common))
-			return -EMSGSIZE;
-		if (copy_from_user(&common, buf, sizeof(common)))
-			return -EFAULT;
-		version = common.version;
-	} else {
-		version = listener->version;
-	}
 	/* size check handled by individual message handlers */
-	return aa_listener_unotif_recv(listener, buf, common.len,
-				       version);
+	return aa_listener_unotif_recv(listener, buf, max_size);
 }
 
 static long notify_user_response(struct aa_listener *listener,
@@ -769,13 +737,7 @@
 			return -EFAULT;
 	}
 
-	if (!notif_supported_version((struct apparmor_notif_common *)&uresp)) {
-		AA_DEBUG(DEBUG_UPCALL, "Failed response listener using unsupported protocol version %d", uresp.base.base.version);
-		error = -EPROTONOSUPPORT;
-		goto out;
-	}
 	error = aa_listener_unotif_response(listener, &uresp, size);
-out:
 	aa_put_buffer((char *) big_resp);
 
 	return error;
@@ -799,101 +761,16 @@
 	return ret;
 }
 
-static long notify_user_register(struct aa_listener *listener,
-				 unsigned long arg, struct file *file)
-{
-	struct apparmor_notif_register_v5 reg;
-	struct aa_listener *found = NULL;
-	void __user *buf = (void __user *)arg;
-	long res;
-
-	if (copy_from_user(&reg.base.len, buf, sizeof(reg.base.len)))
-		return -EFAULT;
-	if (reg.base.len < sizeof(reg))
-		return -EMSGSIZE;
-	if (copy_from_user(&reg, buf, sizeof(reg)))
-		return -EFAULT;
-	/* to balance potential put and retry, ideally would grab from
-	 * file here, but need to refactor for that
-	 */
-	aa_get_listener(listener);
-retry:
-	res = aa_register_listener_id(listener, &reg.listener_id, &found);
-	AA_DEBUG(DEBUG_UPCALL, "registered id %llu found %p res %ld", reg.listener_id, found, res);
-	if (res >= 0) {
-		if (found) {
-			struct aa_listener *l;
-
-			AA_DEBUG(DEBUG_UPCALL, "updating file");
-			struct aa_listener_proxy *proxy;
-
-			spin_lock(&file->f_lock);
-			proxy = file->private_data;
-			if (proxy->listener != listener) {
-				/* raced, try again */
-				l = aa_get_listener(proxy->listener);
-				spin_unlock(&file->f_lock);
-				aa_put_listener(found);
-				aa_put_listener(listener);
-				listener = l;
-				found = NULL;
-				goto retry;
-			}
-			spin_lock(&listener->lock);
-			l = proxy->listener;
-			proxy->listener = NULL;
-			list_del_init(&proxy->llist);
-			spin_unlock(&listener->lock);
-
-			spin_lock(&found->lock);
-			proxy->listener = found; /* transfer search ref */
-			list_add_tail_entry(proxy, &found->ns_proxies,
-					    llist);
-			spin_unlock(&found->lock);
-			spin_unlock(&file->f_lock);
-			aa_put_listener(l);
-			AA_DEBUG(DEBUG_UPCALL, "completed file update");
-		}
-		res = sizeof(reg);
-		if (copy_to_user(buf, &reg, sizeof(reg)))
-			res = -EFAULT;
-	}
-	aa_put_listener(listener);
-	/* size check handled by individual message handlers */
-
-	return res;
-}
-
-static long notify_user_resend(struct aa_listener *listener,
-			       unsigned long arg)
+static long listener_ioctl(struct file *file, unsigned int cmd,
+			 unsigned long arg)
 {
-	struct apparmor_notif_resend_v5 resend;
-	void __user *buf = (void __user *)arg;
-	long res;
-
-	if (copy_from_user(&resend.base.len, buf, sizeof(resend.base.len)))
-		return -EFAULT;
-	if (resend.base.len < sizeof(resend))
-		return -EMSGSIZE;
-	if (copy_from_user(&resend, buf, sizeof(resend)))
-		return -EFAULT;
-	
-	/* size check handled by individual message handlers */
-	res = aa_listener_unotif_resend(listener, &resend.ready,
-					&resend.pending);
-	if (!res) {
-		if (copy_to_user(buf, &resend, sizeof(resend)))
-			return -EFAULT;
-		res = sizeof(resend);
-	}
-	return res;
-}
+	struct aa_listener *listener = file->private_data;
 
+	if (!aa_current_policy_admin_capable(NULL))
+		return -EPERM;
+	if (!listener)
+		return -EINVAL;
 
-static long listener_ioctl_switch(struct file *file,
-				  struct aa_listener *listener,
-				  unsigned int cmd, unsigned long arg)
-{
 	/* todo permission to issue these commands */
 	switch (cmd) {
 	case APPARMOR_NOTIF_SET_FILTER:
@@ -904,51 +781,22 @@
 		return notify_user_response(listener, arg);
 	case APPARMOR_NOTIF_IS_ID_VALID:
 		return notify_is_id_valid(listener, arg);
-	case APPARMOR_NOTIF_REGISTER:
-		return notify_user_register(listener, arg, file);
-	case APPARMOR_NOTIF_RESEND:
-		return notify_user_resend(listener, arg);
-	}
-	return -EINVAL;
-}
-
-static long listener_ioctl(struct file *file, unsigned int cmd,
-			 unsigned long arg)
-{
-	struct aa_listener_proxy *proxy;
-	struct aa_listener *listener;
-	long error;
-
-	if (!aa_current_policy_admin_capable(NULL))
-		return -EPERM;
-
-	spin_lock(&file->f_lock);
-	proxy = file->private_data;
-	listener = aa_get_listener(proxy->listener);
-	spin_unlock(&file->f_lock);
-	if (!listener)
+	default:
 		return -EINVAL;
 
-	error = listener_ioctl_switch(file, listener, cmd, arg);
-	aa_put_listener(listener);
+	}
 
-	return error;
+	return -EINVAL;
 }
 
 static __poll_t listener_poll(struct file *file, poll_table *pt)
 {
-	struct aa_listener_proxy *proxy;
-	struct aa_listener *listener;
+	struct aa_listener *listener = file->private_data;
 	__poll_t mask = 0;
 
 	if (!aa_current_policy_admin_capable(NULL))
 		return EPOLLERR;
 
-	spin_lock(&file->f_lock);
-	proxy = file->private_data;
-	listener = aa_get_listener(proxy->listener);
-	spin_unlock(&file->f_lock);
-
 	if (listener) {
 		spin_lock(&listener->lock);
 		poll_wait(file, &listener->wait, pt);
@@ -958,7 +806,6 @@
 			mask |= EPOLLOUT | EPOLLWRNORM;
 		spin_unlock(&listener->lock);
 	}
-	aa_put_listener(listener);
 
 	return mask;
 }
@@ -2183,8 +2030,8 @@
 	return error;
 }
 
-static struct dentry *ns_mkdir_op(struct mnt_idmap *idmap, struct inode *dir,
-				  struct dentry *dentry, umode_t mode)
+static int ns_mkdir_op(struct mnt_idmap *idmap, struct inode *dir,
+		       struct dentry *dentry, umode_t mode)
 {
 	struct aa_ns *ns, *parent;
 	/* TODO: improve permission check */
@@ -2196,7 +2043,7 @@
 				     AA_MAY_LOAD_POLICY);
 	end_current_label_crit_section(label);
 	if (error)
-		return ERR_PTR(error);
+		return error;
 
 	parent = aa_get_ns(dir->i_private);
 	AA_BUG(d_inode(ns_subns_dir(parent)) != dir);
@@ -2231,7 +2078,7 @@
 	mutex_unlock(&parent->lock);
 	aa_put_ns(parent);
 
-	return ERR_PTR(error);
+	return error;
 }
 
 static int ns_rmdir_op(struct inode *dir, struct dentry *dentry)
@@ -2705,7 +2552,7 @@
 
 static struct aa_sfs_entry aa_sfs_entry_ipc[] = {
 	AA_SFS_FILE_STRING("posix_mqueue",
-			   "create read write open delete setattr getattr label"),
+			   "create read write open delete setattr getattr"),
 	{ }
 };
 
@@ -2735,7 +2582,7 @@
 	AA_SFS_FILE_BOOLEAN("computed_longest_left",	1),
 	AA_SFS_DIR("attach_conditions",		aa_sfs_entry_attach),
 	AA_SFS_FILE_BOOLEAN("interruptible",		1),
-	AA_SFS_FILE_BOOLEAN("disconnected.path",            1),
+	AA_SFS_FILE_BOOLEAN("disconnected.path",	1),
 	AA_SFS_FILE_BOOLEAN("disconnected.ipc",		1),
 	AA_SFS_FILE_BOOLEAN("kill.signal",		1),
 	AA_SFS_FILE_STRING("version", "1.2"),
@@ -2762,13 +2609,7 @@
 };
 
 static struct aa_sfs_entry aa_sfs_entry_notify[] = {
-	AA_SFS_FILE_STRING("user", "file tags"),
-	{ }
-};
-
-static struct aa_sfs_entry aa_sfs_entry_notify_versions[] = {
-	AA_SFS_FILE_BOOLEAN("v3",	1),
-	AA_SFS_FILE_BOOLEAN("v5",	1),
+	AA_SFS_FILE_STRING("user", "file"),
 	{ }
 };
 
@@ -2784,11 +2625,9 @@
 	AA_SFS_FILE_U64("outofband",		MAX_OOB_SUPPORTED),
 	AA_SFS_FILE_U64("permstable32_version",	3),
 	AA_SFS_FILE_STRING("permstable32", PERMS32STR),
-	AA_SFS_FILE_U64("metadata_tagging_version", 1),
 	AA_SFS_FILE_U64("state32",	1),
 	AA_SFS_DIR("unconfined_restrictions",   aa_sfs_entry_unconfined),
 	AA_SFS_DIR("notify",   aa_sfs_entry_notify),
-	AA_SFS_DIR("notify_versions",   aa_sfs_entry_notify_versions),
 	{ }
 };
 
@@ -2832,8 +2671,8 @@
 	AA_SFS_DIR("policy",			aa_sfs_entry_policy),
 	AA_SFS_DIR("domain",			aa_sfs_entry_domain),
 	AA_SFS_DIR("file",			aa_sfs_entry_file),
-	AA_SFS_DIR("network",			aa_sfs_entry_network_compat),
 	AA_SFS_DIR("ipc",			aa_sfs_entry_ipc),
+	AA_SFS_DIR("network",			aa_sfs_entry_network_compat),
 	AA_SFS_DIR("network_v8",		aa_sfs_entry_network),
 	AA_SFS_DIR("network_v9",		aa_sfs_entry_networkv9),
 	AA_SFS_DIR("mount",			aa_sfs_entry_mount),
@@ -2983,7 +2822,7 @@
 		return error;
 
 	inode_lock(d_inode(parent));
-	dentry = lookup_noperm(&QSTR(NULL_FILE_NAME), parent);
+	dentry = lookup_one_len(NULL_FILE_NAME, parent, strlen(NULL_FILE_NAME));
 	if (IS_ERR(dentry)) {
 		error = PTR_ERR(dentry);
 		goto out;
diff -u a/security/apparmor/crypto.c b/security/apparmor/crypto.c
--- a/security/apparmor/crypto.c	2025-10-03 07:37:49.882335169 +0000
+++ b/security/apparmor/crypto.c	2025-10-03 07:27:33.793849263 +0000
@@ -11,52 +11,113 @@
  * it should be.
  */
 
-#include <crypto/sha2.h>
+#include <crypto/hash.h>
 
 #include "include/apparmor.h"
 #include "include/crypto.h"
 
+static unsigned int apparmor_hash_size;
+
+static struct crypto_shash *apparmor_tfm;
+
 unsigned int aa_hash_size(void)
 {
-	return SHA256_DIGEST_SIZE;
+	return apparmor_hash_size;
 }
 
 char *aa_calc_hash(void *data, size_t len)
 {
+	SHASH_DESC_ON_STACK(desc, apparmor_tfm);
 	char *hash;
+	int error;
+
+	if (!apparmor_tfm)
+		return NULL;
 
-	hash = kzalloc(SHA256_DIGEST_SIZE, GFP_KERNEL);
+	hash = kzalloc(apparmor_hash_size, GFP_KERNEL);
 	if (!hash)
 		return ERR_PTR(-ENOMEM);
 
-	sha256(data, len, hash);
+	desc->tfm = apparmor_tfm;
+
+	error = crypto_shash_init(desc);
+	if (error)
+		goto fail;
+	error = crypto_shash_update(desc, (u8 *) data, len);
+	if (error)
+		goto fail;
+	error = crypto_shash_final(desc, hash);
+	if (error)
+		goto fail;
+
 	return hash;
+
+fail:
+	kfree(hash);
+
+	return ERR_PTR(error);
 }
 
 int aa_calc_profile_hash(struct aa_profile *profile, u32 version, void *start,
 			 size_t len)
 {
-	struct sha256_ctx sctx;
+	SHASH_DESC_ON_STACK(desc, apparmor_tfm);
+	int error;
 	__le32 le32_version = cpu_to_le32(version);
 
 	if (!aa_g_hash_policy)
 		return 0;
 
-	profile->hash = kzalloc(SHA256_DIGEST_SIZE, GFP_KERNEL);
+	if (!apparmor_tfm)
+		return 0;
+
+	profile->hash = kzalloc(apparmor_hash_size, GFP_KERNEL);
 	if (!profile->hash)
 		return -ENOMEM;
 
-	sha256_init(&sctx);
-	sha256_update(&sctx, (u8 *)&le32_version, 4);
-	sha256_update(&sctx, (u8 *)start, len);
-	sha256_final(&sctx, profile->hash);
+	desc->tfm = apparmor_tfm;
+
+	error = crypto_shash_init(desc);
+	if (error)
+		goto fail;
+	error = crypto_shash_update(desc, (u8 *) &le32_version, 4);
+	if (error)
+		goto fail;
+	error = crypto_shash_update(desc, (u8 *) start, len);
+	if (error)
+		goto fail;
+	error = crypto_shash_final(desc, profile->hash);
+	if (error)
+		goto fail;
+
 	return 0;
+
+fail:
+	kfree(profile->hash);
+	profile->hash = NULL;
+
+	return error;
 }
 
 static int __init init_profile_hash(void)
 {
-	if (apparmor_initialized)
-		aa_info_message("AppArmor sha256 policy hashing enabled");
+	struct crypto_shash *tfm;
+
+	if (!apparmor_initialized)
+		return 0;
+
+	tfm = crypto_alloc_shash("sha256", 0, 0);
+	if (IS_ERR(tfm)) {
+		int error = PTR_ERR(tfm);
+		AA_ERROR("failed to setup profile sha256 hashing: %d\n", error);
+		return error;
+	}
+	apparmor_tfm = tfm;
+	apparmor_hash_size = crypto_shash_digestsize(apparmor_tfm);
+
+	aa_info_message("AppArmor sha256 policy hashing enabled");
+
 	return 0;
 }
+
 late_initcall(init_profile_hash);
diff -u a/security/apparmor/domain.c b/security/apparmor/domain.c
--- a/security/apparmor/domain.c	2025-09-29 17:33:37.040574794 +0000
+++ b/security/apparmor/domain.c	2025-10-03 07:27:33.793849263 +0000
@@ -28,12 +28,6 @@
 #include "include/policy.h"
 #include "include/policy_ns.h"
 
-static const char * const CONFLICTING_ATTACH_STR = "conflicting profile attachments";
-static const char * const CONFLICTING_ATTACH_STR_IX =
-	"conflicting profile attachments - ix fallback";
-static const char * const CONFLICTING_ATTACH_STR_UX =
-	"conflicting profile attachments - ux fallback";
-
 /**
  * may_change_ptraced_domain - check if can change profile on ptraced task
  * @to_cred: cred of task changing domain
@@ -488,7 +482,7 @@
 
 	if (!candidate || conflict) {
 		if (conflict)
-			*info = CONFLICTING_ATTACH_STR;
+			*info = "conflicting profile attachments";
 		rcu_read_unlock();
 		return NULL;
 	}
@@ -529,7 +523,7 @@
 	/* TODO: move lookup parsing to unpack time so this is a straight
 	 *       index into the resultant label
 	 */
-	for (next = rules->file->trans.table[index].strs; next;
+	for (next = rules->file->trans.table[index]; next;
 	     next = next_name(xtype, next)) {
 		const char *lookup = (*next == '&') ? next + 1 : next;
 		*name = next;
@@ -575,8 +569,6 @@
 	struct aa_label *stack = NULL;
 	struct aa_ns *ns = profile->ns;
 	u32 xtype = xindex & AA_X_TYPE_MASK;
-	/* Used for info checks during fallback handling */
-	const char *old_info = NULL;
 
 	switch (xtype) {
 	case AA_X_NONE:
@@ -613,32 +605,12 @@
 			/* (p|c|n)ix - don't change profile but do
 			 * use the newest version
 			 */
-			if (*info == CONFLICTING_ATTACH_STR) {
-				*info = CONFLICTING_ATTACH_STR_IX;
-			} else {
-				old_info = *info;
-				*info = "ix fallback";
-			}
+			*info = "ix fallback";
 			/* no profile && no error */
 			new = aa_get_newest_label(&profile->label);
 		} else if (xindex & AA_X_UNCONFINED) {
 			new = aa_get_newest_label(ns_unconfined(profile->ns));
-			if (*info == CONFLICTING_ATTACH_STR) {
-				*info = CONFLICTING_ATTACH_STR_UX;
-			} else {
-				old_info = *info;
-				*info = "ux fallback";
-			}
-		}
-		/* We set old_info on the code paths above where overwriting
-		 * could have happened, so now check if info was set by
-		 * find_attach as well (i.e. whether we actually overwrote)
-		 * and warn accordingly.
-		 */
-		if (old_info && old_info != CONFLICTING_ATTACH_STR) {
-			pr_warn_ratelimited(
-				"AppArmor: find_attach (from profile %s) audit info \"%s\" dropped",
-				profile->base.hname, old_info);
+			*info = "ux fallback";
 		}
 	}
 
@@ -691,22 +663,6 @@
 	if (profile_unconfined(profile)) {
 		new = find_attach(bprm, profile->ns,
 				  &profile->ns->base.profiles, name, &info);
-		/* info set -> something unusual that we should report
-		 * Currently this is only conflicting attachments, but other
-		 * infos added in the future should also be logged by default
-		 * and only excluded on a case-by-case basis
-		 */
-		if (info) {
-			/* Because perms is never used again after this audit
-			 * we don't need to care about clobbering it
-			 */
-			perms.audit |= MAY_EXEC;
-			perms.allow |= MAY_EXEC;
-			/* Don't cause error if auditing fails */
-			(void) aa_audit_file(subj_cred, profile, &perms,
-				OP_EXEC, MAY_EXEC, name, target, new, cond->uid,
-				info, error, false);
-		}
 		if (new) {
 			AA_DEBUG(DEBUG_DOMAIN, "unconfined attached to new label");
 			return new;
@@ -722,21 +678,9 @@
 		new = x_to_label(profile, bprm, name, perms.xindex, &target,
 				 &info);
 		if (new && new->proxy == profile->label.proxy && info) {
-			/* Force audit on conflicting attachment fallback
-			 * Because perms is never used again after this audit
-			 * we don't need to care about clobbering it
-			 */
-			if (info == CONFLICTING_ATTACH_STR_IX
-			    || info == CONFLICTING_ATTACH_STR_UX)
-				perms.audit |= MAY_EXEC;
 			/* hack ix fallback - improve how this is detected */
 			goto audit;
 		} else if (!new) {
-			if (info) {
-				pr_warn_ratelimited(
-					"AppArmor: %s (from profile %s) audit info \"%s\" dropped on missing transition",
-					__func__, profile->base.hname, info);
-			}
 			info = "profile transition not found";
 			/* remove MAY_EXEC to audit as failure or complaint */
 			perms.allow &= ~MAY_EXEC;
diff -u a/security/apparmor/file.c b/security/apparmor/file.c
--- a/security/apparmor/file.c	2025-10-03 07:37:49.882335169 +0000
+++ b/security/apparmor/file.c	2025-10-03 07:27:33.793849263 +0000
@@ -154,9 +154,7 @@
 	node->data.subjtsk = current;
 	node->data.type = AUDIT_APPARMOR_USER;
 	node->data.request = ad->request;
-	node->data.tags = ad->tags;
 	node->data.denied = ad->request & ~perms->allow;
-	AA_DEBUG_PROFILE(profile, DEBUG_UPCALL, "attempting upcall\n");
 	err = aa_do_notification(APPARMOR_NOTIF_OP, node);
 	put_task_struct(node->data.subjtsk);
 
@@ -207,7 +205,6 @@
 
 	ad.subj_cred = subj_cred;
 	ad.request = request;
-	ad.tags = perms->tag;
 	ad.name = name;
 	ad.fs.target = target;
 	ad.peer = tlabel;
@@ -252,8 +249,7 @@
 				/* are there other errors we should bail on */
 				return err;
 			}
-		} else
-			AA_DEBUG_PROFILE(profile, DEBUG_UPCALL, "not prompting prompt %d, requiest 0x%x, deny 0x%x, prompt 0x%x implicit deny 0x%x", prompt, request, perms->deny, perms->prompt, implicit_deny);
+		}
 	}
 
 	if (likely(!ad.error)) {
@@ -293,8 +289,7 @@
 static int path_name(const char *op, const struct cred *subj_cred,
 		     struct aa_label *label,
 		     const struct path *path, int flags, char *buffer,
-		     const char **name, struct path_cond *cond, u32 request,
-		     bool prompt)
+		     const char **name, struct path_cond *cond, u32 request)
 {
 	struct aa_profile *profile;
 	const char *info = NULL;
@@ -306,8 +301,7 @@
 		fn_for_each_confined(label, profile,
 			aa_audit_file(subj_cred,
 				      profile, &nullperms, op, request, *name,
-				      NULL, NULL, cond->uid, info, error,
-				      prompt));
+				      NULL, NULL, cond->uid, info, error, true));
 		return error;
 	}
 
@@ -401,15 +395,15 @@
 
 	error = path_name(op, subj_cred, &profile->label, path,
 			  flags | profile->path_flags, buffer, &name, cond,
-			  request, prompt);
+			  request);
 	if (error)
 		return error;
 	error = __aa_path_perm(op, subj_cred, profile, name, request, cond,
 			       flags, perms, prompt);
 	/* accumulate intersection of allowed to set on object cache */
-	if (!error && allow)
+	if (!error && allow) {
 		*allow &= perms->allow;
-
+	}
 	return error;
 }
 
@@ -487,14 +481,14 @@
 
 	error = path_name(OP_LINK, subj_cred, &profile->label, link,
 			  profile->path_flags,
-			  buffer, &lname, cond, AA_MAY_LINK, false);
+			  buffer, &lname, cond, AA_MAY_LINK);
 	if (error)
 		goto audit;
 
 	/* buffer2 freed below, tname is pointer in buffer2 */
 	error = path_name(OP_LINK, subj_cred, &profile->label, target,
 			  profile->path_flags,
-			  buffer2, &tname, cond, AA_MAY_LINK, false);
+			  buffer2, &tname, cond, AA_MAY_LINK);
 	if (error)
 		goto audit;
 
@@ -633,36 +627,39 @@
 	spin_unlock(&fctx->lock);
 }
 
-static int __path_perm(const char *op, const struct cred *subj_cred,
-		       struct aa_label *label, struct aa_label *flabel,
-		       struct file *file, u32 request, u32 denied,
-		       struct path_cond *cond, int flags,
-		       bool in_atomic, bool is_mqueue,
-		       struct apparmor_audit_data *ad)
+static int __file_path_perm(const char *op, const struct cred *subj_cred,
+			    struct aa_label *label,
+			    struct aa_label *flabel, struct file *file,
+			    u32 request, u32 denied, bool in_atomic)
 {
 	struct aa_profile *profile;
 	struct aa_perms perms = {};
+	vfsuid_t vfsuid = i_uid_into_vfsuid(file_mnt_idmap(file),
+					    file_inode(file));
+	struct path_cond cond = {
+		.uid = vfsuid_into_kuid(vfsuid),
+		.mode = file_inode(file)->i_mode
+	};
 	char *buffer;
 	u32 allow = ALL_PERMS_MASK;
-	int error;
+	int flags, error;
 
 	/* revalidation due to label out of date. No revocation at this time */
 	if (!denied && aa_label_is_subset(flabel, label))
 		/* TODO: check for revocation on stale profiles */
 		return 0;
 
+	flags = PATH_DELEGATE_DELETED | (S_ISDIR(cond.mode) ? PATH_IS_DIR : 0);
 	buffer = aa_get_buffer(in_atomic);
 	if (!buffer)
 		return -ENOMEM;
 
 	/* check every profile in task label not in current cache */
-	error = fn_for_each_not_in_set(flabel, label, profile, is_mqueue ?
-			aa_profile_mqueue_perm(profile, &file->f_path,
-					       request, buffer, ad) :
+	error = fn_for_each_not_in_set(flabel, label, profile,
 			profile_path_perm(op, subj_cred, profile,
 					  &file->f_path, buffer,
-					  request, cond, flags, &perms,
-					  &allow, !in_atomic));
+					  request, &cond, flags, &perms,
+					  &allow, false));
 	if (denied && !error) {
 		/*
 		 * check every profile in file label that was not tested
@@ -673,51 +670,26 @@
 		 * TODO: don't audit here
 		 */
 		if (label == flabel)
-			error = fn_for_each(label, profile, is_mqueue ?
-				aa_profile_mqueue_perm(profile, &file->f_path,
-						       request, buffer, ad) :
+			error = fn_for_each(label, profile,
 				profile_path_perm(op, subj_cred,
 						  profile, &file->f_path,
-						  buffer, request, cond, flags,
-						  &perms, &allow, !in_atomic));
+						  buffer, request, &cond, flags,
+						  &perms, &allow, false));
 		else
-			error = fn_for_each_not_in_set(label, flabel, profile, is_mqueue ?
-				aa_profile_mqueue_perm(profile, &file->f_path,
-						       request, buffer, ad) :
+			error = fn_for_each_not_in_set(label, flabel, profile,
 				profile_path_perm(op, subj_cred,
 						  profile, &file->f_path,
-						  buffer, request, cond, flags,
-						  &perms, &allow, !in_atomic));
+						  buffer, request, &cond, flags,
+						  &perms, &allow, false));
 	}
 	if (!error)
-		update_file_ctx(file_ctx(file), label, request,
-				is_mqueue ? request : allow);
+		update_file_ctx(file_ctx(file), label, request, allow);
 
 	aa_put_buffer(buffer);
 
 	return error;
 }
 
-static int __file_path_perm(const char *op, const struct cred *subj_cred,
-			    struct aa_label *label,
-			    struct aa_label *flabel, struct file *file,
-			    u32 request, u32 denied, bool in_atomic)
-{
-	vfsuid_t vfsuid = i_uid_into_vfsuid(file_mnt_idmap(file),
-					    file_inode(file));
-	struct path_cond cond = {
-		.uid = vfsuid_into_kuid(vfsuid),
-		.mode = file_inode(file)->i_mode
-	};
-	int flags;
-
-	flags = PATH_DELEGATE_DELETED | (S_ISDIR(cond.mode) ? PATH_IS_DIR : 0);
-
-	return __path_perm(op, subj_cred, label, flabel, file,
-			   request, denied, &cond, flags, in_atomic,
-			   false, NULL);
-}
-
 static int __file_sock_perm(const char *op, const struct cred *subj_cred,
 			    struct aa_label *label,
 			    struct aa_label *flabel, struct file *file,
@@ -743,50 +715,72 @@
 	return error;
 }
 
+/* TODO: combine with __file_path_perm */
 static int __file_mqueue_perm(const char *op, const struct cred *subj_cred,
 			      struct aa_label *label,
 			      struct aa_label *flabel, struct file *file,
 			      u32 request, u32 denied, bool in_atomic)
 {
+	struct aa_profile *profile;
+	char *buffer;
+	int error;
 	DEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_NONE, AA_CLASS_POSIX_MQUEUE, op);
 
+	/* revalidation due to label out of date. No revocation at this time */
+	if (!denied && aa_label_is_subset(flabel, label))
+		/* TODO: check for revocation on stale profiles */
+		return 0;
+
+	buffer = aa_get_buffer(in_atomic);
+	if (!buffer)
+		return -ENOMEM;
+
 	ad.subj_cred = subj_cred;
 	ad.request = request;
 	ad.peer = NULL;
 	ad.mq.ouid = file_inode(file)->i_uid;
 
-	return __path_perm(op, subj_cred, label, flabel, file,
-			   request, denied, NULL, 0, in_atomic,
-			   true, &ad);
+	/* check every profile in task label not in current cache */
+	error = fn_for_each_not_in_set(flabel, label, profile,
+			aa_profile_mqueue_perm(profile, &file->f_path,
+					       request, buffer, &ad));
+	if (denied && !error) {
+		/*
+		 * check every profile in file label that was not tested
+		 * in the initial check above.
+		 *
+		 * TODO: cache full perms so this only happens because of
+		 * conditionals
+		 * TODO: don't audit here
+		 */
+		if (label == flabel)
+			error = fn_for_each(label, profile,
+				aa_profile_mqueue_perm(profile, &file->f_path,
+						       request, buffer, &ad));
+		else
+			error = fn_for_each_not_in_set(label, flabel, profile,
+				aa_profile_mqueue_perm(profile, &file->f_path,
+						       request, buffer, &ad));
+	}
+	if (!error)
+		update_file_ctx(file_ctx(file), label, request, request);
+
+	aa_put_buffer(buffer);
+
+	return error;
 }
 
-/* for now separate fn to indicate semantics of the check */
-static bool __file_is_delegated(struct aa_label *obj_label)
+/* wrapper fn to indicate semantics of the check */
+static bool __subj_label_is_cached(struct aa_label *subj_label,
+			    struct aa_label *obj_label)
 {
-	return unconfined(obj_label);
+	return aa_label_is_subset(obj_label, subj_label);
 }
 
-static bool __unix_needs_revalidation(struct file *file, struct aa_label *label,
-				      u32 request)
+/* for now separate fn to indicate semantics of the check */
+static bool __file_is_delegated(struct aa_label *obj_label)
 {
-	struct socket *sock = (struct socket *) file->private_data;
-
-	lockdep_assert_in_rcu_read_lock();
-
-	if (!S_ISSOCK(file_inode(file)->i_mode))
-		return false;
-	if (request & NET_PEER_MASK)
-		return false;
-	if (sock->sk->sk_family == PF_UNIX) {
-		struct aa_sk_ctx *ctx = aa_sock(sock->sk);
-
-		if (rcu_access_pointer(ctx->peer) !=
-		    rcu_access_pointer(ctx->peer_lastupdate))
-			return true;
-		return !__aa_subj_label_is_cached(rcu_dereference(ctx->label),
-						  label);
-	}
-	return false;
+	return unconfined(obj_label);
 }
 
 /**
@@ -827,20 +821,19 @@
 	 */
 	denied = request & ~fctx->allow;
 	if (unconfined(label) || __file_is_delegated(flabel) ||
-	    __unix_needs_revalidation(file, label, request) ||
-	    (!denied && __aa_subj_label_is_cached(label, flabel))) {
+	    (!denied && __subj_label_is_cached(label, flabel))) {
 		rcu_read_unlock();
 		goto done;
 	}
 
-	/* slow path - revalidate access */
 	flabel  = aa_get_newest_label(flabel);
 	rcu_read_unlock();
+	/* TODO: label cross check */
 
 	if (is_mqueue_inode(file_inode(file))) {
 		error = __file_mqueue_perm(op, subj_cred, label, flabel, file,
 					   request, denied, in_atomic);
-	} else if (path_mediated_fs(file->f_path.dentry))
+	} else if (file->f_path.mnt && path_mediated_fs(file->f_path.dentry))
 		error = __file_path_perm(op, subj_cred, label, flabel, file,
 					 request, denied, in_atomic);
 
Common subdirectories: a/security/apparmor/include and b/security/apparmor/include
diff -u a/security/apparmor/ipc.c b/security/apparmor/ipc.c
--- a/security/apparmor/ipc.c	2025-09-29 17:33:37.041574841 +0000
+++ b/security/apparmor/ipc.c	2025-10-03 07:27:33.794849305 +0000
@@ -126,7 +126,7 @@
 	aa_audit_perms(ab, ad, NULL, 0, NULL, AA_AUDIT_POSIX_MQUEUE_MASK);
 
 	/* move class into generic audit framse work */
-	audit_log_format(ab, " class=\"posix_mqueue\"");
+	audit_log_format(ab, "class=\"posix_mqueue\"");
 	if (ad->request & AA_AUDIT_FILE_MASK) {
 		audit_log_format(ab, " fsuid=%u",
 				 from_kuid(&init_user_ns, ad->subj_cred->fsuid));
@@ -148,7 +148,6 @@
 	struct aa_perms perms = { };
 	unsigned int state;
 	char *name;
-	struct aa_inode_sec *isec;
 
 	if (profile_unconfined(profile) ||
 	    !RULE_MEDIATES(rules, AA_CLASS_POSIX_MQUEUE))
@@ -186,22 +185,10 @@
 				      audit_mqueue_cb);
 	}
 	/* continue check to see if we have label perms */
-	if (!(request & AA_MAY_CREATE)) {
-		if (!d_backing_inode(path->dentry)) {
-			pr_warn("apparmor: could not get inode\n");
-			goto err;
-		}
-		isec = apparmor_inode(d_backing_inode(path->dentry));
-		if (!isec) {
-			pr_warn("apparmor: could not get inode sec context\n");
-			goto err;
-		}
-		ad->peer = isec->label;
-		state = aa_dfa_null_transition(rules->policy->dfa, state);
-		aa_label_match(profile, rules, isec->label, state, false, request, &perms);
-		aa_apply_modes_to_perms(profile, &perms);
-	}
-err:
+	//aa_label_match(profile, peer??, state false, request, &perms);
+	//aa_apply_modes_to_perms(profile, &perms);
+
+	// this will just cause failure without above label check
 	return aa_check_perms(profile, &perms, request, ad, audit_mqueue_cb);
 }
 
diff -u a/security/apparmor/lib.c b/security/apparmor/lib.c
--- a/security/apparmor/lib.c	2025-09-29 17:33:37.041574841 +0000
+++ b/security/apparmor/lib.c	2025-10-03 07:27:33.794849305 +0000
@@ -45,8 +45,6 @@
 	{ "policy", DEBUG_POLICY },
 	{ "interface", DEBUG_INTERFACE },
 	{ "upcall", DEBUG_UPCALL },
-	{ "unpack", DEBUG_UNPACK },
-	{ "tags", DEBUG_TAGS },
 	{ NULL, 0 }
 };
 
@@ -87,8 +85,8 @@
 /**
  * val_mask_to_str - convert a perm mask to its short string
  * @str: character buffer to store string in (at least 10 characters)
- * @size: size of the @str buffer
- * @table: NUL-terminated character buffer of permission characters (NOT NULL)
+ * @str_size: size of the @str buffer
+ * @chrs: NUL-terminated character buffer of permission characters
  * @mask: permission mask to convert
  */
 static int val_mask_to_str(char *str, size_t size,
@@ -119,34 +117,11 @@
 			       aa_g_debug);
 }
 
-bool aa_resize_str_table(struct aa_str_table *t, int newsize, gfp_t gfp)
-{
-	struct aa_str_table_ent *n;
-	int i;
-
-	if (t->size == newsize)
-		return true;
-	n = kcalloc(newsize, sizeof(*n), gfp);
-	if (!n)
-		return false;
-	for (i = 0; i < min(t->size, newsize); i++)
-		n[i] = t->table[i];
-	for (; i < t->size; i++)
-		kfree_sensitive(t->table[i].strs);
-	if (newsize > t->size)
-		memset(&n[t->size], 0, (newsize-t->size)*sizeof(*n));
-	kfree_sensitive(t->table);
-	t->table = n;
-	t->size = newsize;
-
-	return true;
-}
-
 /**
- * aa_destroy_str_table - free entries str table
+ * aa_free_str_table - free entries str table
  * @t: the string table to free  (MAYBE NULL)
  */
-void aa_destroy_str_table(struct aa_str_table *t)
+void aa_free_str_table(struct aa_str_table *t)
 {
 	int i;
 
@@ -154,9 +129,8 @@
 		if (!t->table)
 			return;
 
-		for (i = 0; i < t->size; i++) {
-			kfree_sensitive(t->table[i].strs);
-		}
+		for (i = 0; i < t->size; i++)
+			kfree_sensitive(t->table[i]);
 		kfree_sensitive(t->table);
 		t->table = NULL;
 		t->size = 0;
@@ -252,7 +226,7 @@
 
 
 const char aa_file_perm_chrs[] = "xwracd         km l     ";
-static const char * const aa_base_perm_names[] = {
+static const char *aa_base_perm_names[] = {
 	"exec",
 	"write",
 	"read",
diff -u a/security/apparmor/lsm.c b/security/apparmor/lsm.c
--- a/security/apparmor/lsm.c	2025-09-29 17:33:37.041574841 +0000
+++ b/security/apparmor/lsm.c	2025-10-03 07:27:33.794849305 +0000
@@ -138,15 +138,14 @@
 	struct aa_label *tracer, *tracee;
 	const struct cred *cred;
 	int error;
-	bool needput;
 
 	cred = get_task_cred(child);
 	tracee = cred_label(cred);	/* ref count on cred */
-	tracer = __begin_current_label_crit_section(&needput);
+	tracer = __begin_current_label_crit_section();
 	error = aa_may_ptrace(current_cred(), tracer, cred, tracee,
 			(mode & PTRACE_MODE_READ) ? AA_PTRACE_READ
 						  : AA_PTRACE_TRACE);
-	__end_current_label_crit_section(tracer, needput);
+	__end_current_label_crit_section(tracer);
 	put_cred(cred);
 
 	return error;
@@ -157,15 +156,14 @@
 	struct aa_label *tracer, *tracee;
 	const struct cred *cred;
 	int error;
-	bool needput;
 
-	tracee = __begin_current_label_crit_section(&needput);
+	tracee = __begin_current_label_crit_section();
 	cred = get_task_cred(parent);
 	tracer = cred_label(cred);	/* ref count on cred */
 	error = aa_may_ptrace(cred, tracer, current_cred(), tracee,
 			      AA_PTRACE_TRACE);
 	put_cred(cred);
-	__end_current_label_crit_section(tracee, needput);
+	__end_current_label_crit_section(tracee);
 
 	return error;
 }
@@ -190,8 +188,10 @@
 		struct label_it i;
 
 		label_for_each_confined(i, label, profile) {
+			struct aa_ruleset *rules;
 			kernel_cap_t allowed;
 
+			rules = profile->label.rules[0];
 			allowed = aa_profile_capget(profile);
 			*effective = cap_intersect(*effective, allowed);
 			*permitted = cap_intersect(*permitted, allowed);
@@ -231,13 +231,12 @@
 {
 	struct aa_label *label;
 	int error = 0;
-	bool needput;
 
-	label = __begin_current_label_crit_section(&needput);
+	label = __begin_current_label_crit_section();
 	if (!unconfined(label))
 		error = aa_path_perm(op, current_cred(), label, path, 0, mask,
 				     cond, NULL);
-	__end_current_label_crit_section(label, needput);
+	__end_current_label_crit_section(label);
 
 	return error;
 }
@@ -508,12 +507,35 @@
 {
 	struct aa_inode_sec *isec = apparmor_inode(inode);
 
-	if (unlikely(!isec))
+	if (!isec)
 		return;
 
 	aa_put_label(isec->label);
 }
 
+
+/* this is broken, in that we must make it work for ALL xattr fs
+ * or it will bail early, so this does not work with LSM stacking
+ */
+static int apparmor_inode_init_security(struct inode *inode, struct inode *dir,
+				       const struct qstr *qstr,
+				       struct xattr *xattrs, int *xattr_count)
+{
+	struct aa_inode_sec *isec = apparmor_inode(inode);
+
+	if (is_mqueue_inode(dir)) {
+		/* only initialize based on implied label atm */
+		isec->label = aa_get_current_label();
+		isec->sclass = AA_CLASS_POSIX_MQUEUE;
+		isec->initialized = true;
+	}
+
+	/* we aren't setting xattrs yet so pretend it isn't supported,
+	 * note bug in LSM means other LSMs won't get to init inode either
+	 */
+	return -EOPNOTSUPP;
+}
+
 static int inode_init_with_dentry(struct inode *inode, struct dentry *dentry)
 {
 	struct aa_inode_sec *isec = apparmor_inode(inode);
@@ -538,22 +560,6 @@
 	return 0;
 }
 
-static int apparmor_inode_init_security(struct inode *inode, struct inode *dir,
-				       const struct qstr *qstr,
-				       struct xattr *xattrs, int *xattr_count)
-{
-	int error;
-
-	error = inode_init_with_dentry(inode, NULL);
-	if (error)
-		return error;
-
-	/* we aren't setting xattrs yet so -EOPNOTSUPP indicates
-	 * that, not an error
-	 */
-	return -EOPNOTSUPP;
-}
-
 static void apparmor_d_instantiate(struct dentry *dentry, struct inode *inode)
 {
 	if (inode)
@@ -612,7 +618,7 @@
 	/* TODO: extend to support iattr as a parameter */
 	if (is_mqueue_dentry(dentry))
 		/* TODO: fn() for d_parent */
-		return common_mqueue_perm(OP_SETATTR, AA_MAY_SETATTR,
+		return common_mqueue_perm(OP_UNLINK, AA_MAY_SETATTR,
 				  d_backing_inode(dentry->d_parent), dentry);
 
 	return 0;
@@ -652,7 +658,7 @@
 		vfsuid = i_uid_into_vfsuid(idmap, inode);
 		cond.uid = vfsuid_into_kuid(vfsuid);
 
-		if (is_mqueue_inode(file_inode(file))) {
+		if (is_mqueue_inode(file_inode(file))){
 			error = aa_mqueue_perm(OP_OPEN, file->f_cred,
 					       label, &file->f_path,
 					       aa_map_file_to_perms(file));
@@ -698,15 +704,14 @@
 {
 	struct aa_label *label;
 	int error = 0;
-	bool needput;
 
 	/* don't reaudit files closed during inheritance */
-	if (unlikely(file->f_path.dentry == aa_null.dentry))
+	if (file->f_path.dentry == aa_null.dentry)
 		return -EACCES;
 
-	label = __begin_current_label_crit_section(&needput);
+	label = __begin_current_label_crit_section();
 	error = aa_file_perm(op, current_cred(), label, file, mask, in_atomic);
-	__end_current_label_crit_section(label, needput);
+	__end_current_label_crit_section(label);
 
 	return error;
 }
@@ -757,7 +762,7 @@
 static int apparmor_mmap_file(struct file *file, unsigned long reqprot,
 			      unsigned long prot, unsigned long flags)
 {
-	return common_mmap(OP_FMMAP, file, prot, flags, false);
+	return common_mmap(OP_FMMAP, file, prot, flags, GFP_ATOMIC);
 }
 
 static int apparmor_file_mprotect(struct vm_area_struct *vma,
@@ -866,16 +871,15 @@
 	struct aa_profile *profile;
 	struct aa_label *label;
 	int error;
-	bool needput;
 	DEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_NONE, AA_CLASS_IO_URING,
 			  OP_URING_OVERRIDE);
 
 	ad.uring.target = cred_label(new);
-	label = __begin_current_label_crit_section(&needput);
+	label = __begin_current_label_crit_section();
 	error = fn_for_each(label, profile,
 			profile_uring(profile, AA_MAY_OVERRIDE_CRED,
 				      cred_label(new), CAP_SYS_ADMIN, &ad));
-	__end_current_label_crit_section(label, needput);
+	__end_current_label_crit_section(label);
 
 	return error;
 }
@@ -891,15 +895,14 @@
 	struct aa_profile *profile;
 	struct aa_label *label;
 	int error;
-	bool needput;
 	DEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_NONE, AA_CLASS_IO_URING,
 			  OP_URING_SQPOLL);
 
-	label = __begin_current_label_crit_section(&needput);
+	label = __begin_current_label_crit_section();
 	error = fn_for_each(label, profile,
 			profile_uring(profile, AA_MAY_CREATE_SQPOLL,
 				      NULL, CAP_SYS_ADMIN, &ad));
-	__end_current_label_crit_section(label, needput);
+	__end_current_label_crit_section(label);
 
 	return error;
 }
@@ -910,7 +913,6 @@
 {
 	struct aa_label *label;
 	int error = 0;
-	bool needput;
 
 	/* Discard magic */
 	if ((flags & MS_MGC_MSK) == MS_MGC_VAL)
@@ -918,7 +920,7 @@
 
 	flags &= ~AA_MS_IGNORE_MASK;
 
-	label = __begin_current_label_crit_section(&needput);
+	label = __begin_current_label_crit_section();
 	if (!unconfined(label)) {
 		if (flags & MS_REMOUNT)
 			error = aa_remount(current_cred(), label, path, flags,
@@ -937,7 +939,7 @@
 			error = aa_new_mount(current_cred(), label, dev_name,
 					     path, type, flags, data);
 	}
-	__end_current_label_crit_section(label, needput);
+	__end_current_label_crit_section(label);
 
 	return error;
 }
@@ -947,13 +949,12 @@
 {
 	struct aa_label *label;
 	int error = 0;
-	bool needput;
 
-	label = __begin_current_label_crit_section(&needput);
+	label = __begin_current_label_crit_section();
 	if (!unconfined(label))
 		error = aa_move_mount(current_cred(), label, from_path,
 				      to_path);
-	__end_current_label_crit_section(label, needput);
+	__end_current_label_crit_section(label);
 
 	return error;
 }
@@ -962,12 +963,11 @@
 {
 	struct aa_label *label;
 	int error = 0;
-	bool needput;
 
-	label = __begin_current_label_crit_section(&needput);
+	label = __begin_current_label_crit_section();
 	if (!unconfined(label))
 		error = aa_umount(current_cred(), label, mnt, flags);
-	__end_current_label_crit_section(label, needput);
+	__end_current_label_crit_section(label);
 
 	return error;
 }
@@ -1191,12 +1191,10 @@
 
 static void apparmor_current_getlsmprop_subj(struct lsm_prop *prop)
 {
-	struct aa_label *label;
-	bool needput;
+	struct aa_label *label = __begin_current_label_crit_section();
 
-	label = __begin_current_label_crit_section(&needput);
 	prop->apparmor.label = label;
-	__end_current_label_crit_section(label, needput);
+	__end_current_label_crit_section(label);
 }
 
 static void apparmor_task_getlsmprop_obj(struct task_struct *p,
@@ -1211,16 +1209,13 @@
 static int apparmor_task_setrlimit(struct task_struct *task,
 		unsigned int resource, struct rlimit *new_rlim)
 {
-	struct aa_label *label;
+	struct aa_label *label = __begin_current_label_crit_section();
 	int error = 0;
-	bool needput;
-
-	label = __begin_current_label_crit_section(&needput);
 
 	if (!unconfined(label))
 		error = aa_task_setrlimit(current_cred(), label, task,
 					  resource, new_rlim);
-	__end_current_label_crit_section(label, needput);
+	__end_current_label_crit_section(label);
 
 	return error;
 }
@@ -1231,7 +1226,6 @@
 	const struct cred *tc;
 	struct aa_label *cl, *tl;
 	int error;
-	bool needput;
 
 	tc = get_task_cred(target);
 	tl = aa_get_newest_cred_label(tc);
@@ -1243,9 +1237,9 @@
 		error = aa_may_signal(cred, cl, tc, tl, sig);
 		aa_put_label(cl);
 	} else {
-		cl = __begin_current_label_crit_section(&needput);
+		cl = __begin_current_label_crit_section();
 		error = aa_may_signal(current_cred(), cl, tc, tl, sig);
-		__end_current_label_crit_section(cl, needput);
+		__end_current_label_crit_section(cl);
 	}
 	aa_put_label(tl);
 	put_cred(tc);
@@ -1285,29 +1279,12 @@
 	return error;
 }
 
-static int apparmor_sk_alloc_security(struct sock *sk, int family, gfp_t gfp)
-{
-	struct aa_sk_ctx *ctx = aa_sock(sk);
-	struct aa_label *label;
-	bool needput;
-
-	label = __begin_current_label_crit_section(&needput);
-	//spin_lock_init(&ctx->lock);
-	rcu_assign_pointer(ctx->label, aa_get_label(label));
-	rcu_assign_pointer(ctx->peer, NULL);
-	rcu_assign_pointer(ctx->peer_lastupdate, NULL);
-	__end_current_label_crit_section(label, needput);
-	return 0;
-}
-
 static void apparmor_sk_free_security(struct sock *sk)
 {
 	struct aa_sk_ctx *ctx = aa_sock(sk);
 
-	/* dead these won't be updated any more */
-	aa_put_label(rcu_dereference_protected(ctx->label, true));
-	aa_put_label(rcu_dereference_protected(ctx->peer, true));
-	aa_put_label(rcu_dereference_protected(ctx->peer_lastupdate, true));
+	aa_put_label(ctx->label);
+	aa_put_label(ctx->peer);
 }
 
 /**
@@ -1321,22 +1298,13 @@
 	struct aa_sk_ctx *ctx = aa_sock(sk);
 	struct aa_sk_ctx *new = aa_sock(newsk);
 
-	/* not actually in use yet */
-	if (rcu_access_pointer(ctx->label) != rcu_access_pointer(new->label)) {
-		aa_put_label(rcu_dereference_protected(new->label, true));
-		rcu_assign_pointer(new->label, aa_get_label_rcu(&ctx->label));
-	}
-
-	if (rcu_access_pointer(ctx->peer) != rcu_access_pointer(new->peer)) {
-		aa_put_label(rcu_dereference_protected(new->peer, true));
-		rcu_assign_pointer(new->peer, aa_get_label_rcu(&ctx->peer));
-	}
-
-	if (rcu_access_pointer(ctx->peer_lastupdate) != rcu_access_pointer(new->peer_lastupdate)) {
-		aa_put_label(rcu_dereference_protected(new->peer_lastupdate, true));
-		rcu_assign_pointer(new->peer_lastupdate,
-				   aa_get_label_rcu(&ctx->peer_lastupdate));
-	}
+	if (new->label)
+		aa_put_label(new->label);
+	new->label = aa_get_label(ctx->label);
+
+	if (new->peer)
+		aa_put_label(new->peer);
+	new->peer = aa_get_label(ctx->peer);
 }
 
 static int unix_connect_perm(const struct cred *cred, struct aa_label *label,
@@ -1347,59 +1315,33 @@
 
 	error = aa_unix_peer_perm(cred, label, OP_CONNECT,
 				(AA_MAY_CONNECT | AA_MAY_SEND | AA_MAY_RECEIVE),
-				  sk, peer_sk,
-				  rcu_dereference_protected(peer_ctx->label,
-				     lockdep_is_held(&unix_sk(peer_sk)->lock)));
+				  sk, peer_sk, NULL);
 	if (!is_unix_fs(peer_sk)) {
 		last_error(error,
 			   aa_unix_peer_perm(cred,
-				rcu_dereference_protected(peer_ctx->label,
-				     lockdep_is_held(&unix_sk(peer_sk)->lock)),
-				OP_CONNECT,
+				peer_ctx->label, OP_CONNECT,
 				(AA_MAY_ACCEPT | AA_MAY_SEND | AA_MAY_RECEIVE),
-							  peer_sk, sk, label));
+				peer_sk, sk, label));
 	}
 
 	return error;
 }
 
-/* lockdep check in unix_connect_perm - push sks here to check */
 static void unix_connect_peers(struct aa_sk_ctx *sk_ctx,
 			       struct aa_sk_ctx *peer_ctx)
 {
 	/* Cross reference the peer labels for SO_PEERSEC */
-	struct aa_label *label = rcu_dereference_protected(sk_ctx->label, true);
+	aa_put_label(peer_ctx->peer);
+	aa_put_label(sk_ctx->peer);
 
-	aa_get_label(label);
-	aa_put_label(rcu_dereference_protected(peer_ctx->peer,
-					     true));
-	rcu_assign_pointer(peer_ctx->peer, label);	/* transfer cnt */
-
-	label = aa_get_label(rcu_dereference_protected(peer_ctx->label,
-					     true));
-	//spin_unlock(&peer_ctx->lock);
-
-	//spin_lock(&sk_ctx->lock);
-	aa_put_label(rcu_dereference_protected(sk_ctx->peer,
-					       true));
-	aa_put_label(rcu_dereference_protected(sk_ctx->peer_lastupdate,
-					       true));
-
-	rcu_assign_pointer(sk_ctx->peer, aa_get_label(label));
-	rcu_assign_pointer(sk_ctx->peer_lastupdate, label);     /* transfer cnt */
-	//spin_unlock(&sk_ctx->lock);
+	peer_ctx->peer = aa_get_label(sk_ctx->label);
+	sk_ctx->peer = aa_get_label(peer_ctx->label);
 }
 
 /**
  * apparmor_unix_stream_connect - check perms before making unix domain conn
- * @sk: sk attempting to connect
- * @peer_sk: sk that is accepting the connection
- * @newsk: new sk created for this connection
- * peer is locked when this hook is called
  *
- * Return:
- *   0 if connection is permitted
- *   error code on denial or failure
+ * peer is locked when this hook is called
  */
 static int apparmor_unix_stream_connect(struct sock *sk, struct sock *peer_sk,
 					struct sock *newsk)
@@ -1409,21 +1351,17 @@
 	struct aa_sk_ctx *new_ctx = aa_sock(newsk);
 	struct aa_label *label;
 	int error;
-	bool needput;
 
-	label = __begin_current_label_crit_section(&needput);
+	label = __begin_current_label_crit_section();
 	error = unix_connect_perm(current_cred(), label, sk, peer_sk);
-	__end_current_label_crit_section(label, needput);
+	__end_current_label_crit_section(label);
 
 	if (error)
 		return error;
 
-	/* newsk doesn't go through post_create, but does go through
-	 * security_sk_alloc()
-	 */
-	rcu_assign_pointer(new_ctx->label,
-			   aa_get_label(rcu_dereference_protected(peer_ctx->label,
-								  true)));
+	/* newsk doesn't go through post_create */
+	AA_BUG(new_ctx->label);
+	new_ctx->label = aa_get_label(peer_ctx->label);
 
 	/* Cross reference the peer labels for SO_PEERSEC */
 	unix_connect_peers(sk_ctx, new_ctx);
@@ -1433,39 +1371,26 @@
 
 /**
  * apparmor_unix_may_send - check perms before conn or sending unix dgrams
- * @sock: socket sending the message
- * @peer: socket message is being send to
- *
- * Performs bidirectional permission checks for Unix domain socket communication:
- * 1. Verifies sender has AA_MAY_SEND to target socket
- * 2. Verifies receiver has AA_MAY_RECEIVE from source socket
  *
  * sock and peer are locked when this hook is called
- * called by: dgram_connect peer setup but path not copied to newsk
  *
- * Return:
- *   0 if transmission is permitted
- *   error code on denial or failure
+ * called by: dgram_connect peer setup but path not copied to newsk
  */
 static int apparmor_unix_may_send(struct socket *sock, struct socket *peer)
 {
 	struct aa_sk_ctx *peer_ctx = aa_sock(peer->sk);
 	struct aa_label *label;
 	int error;
-	bool needput;
 
-	label = __begin_current_label_crit_section(&needput);
+	label = __begin_current_label_crit_section();
 	error = xcheck(aa_unix_peer_perm(current_cred(),
-				label, OP_SENDMSG, AA_MAY_SEND,
-				sock->sk, peer->sk,
-				rcu_dereference_protected(peer_ctx->label,
-							  true)),
+					 label, OP_SENDMSG, AA_MAY_SEND,
+					 sock->sk, peer->sk, NULL),
 		       aa_unix_peer_perm(peer->file ? peer->file->f_cred : NULL,
-				rcu_dereference_protected(peer_ctx->label,
-							  true),
-				OP_SENDMSG, AA_MAY_RECEIVE, peer->sk,
-				sock->sk, label));
-	__end_current_label_crit_section(label, needput);
+					 peer_ctx->label, OP_SENDMSG,
+					 AA_MAY_RECEIVE,
+					 peer->sk, sock->sk, label));
+	__end_current_label_crit_section(label);
 
 	return error;
 }
@@ -1530,9 +1455,8 @@
 	if (sock->sk) {
 		struct aa_sk_ctx *ctx = aa_sock(sock->sk);
 
-		/* still not live */
-		aa_put_label(rcu_dereference_protected(ctx->label, true));
-		rcu_assign_pointer(ctx->label, aa_get_label(label));
+		aa_put_label(ctx->label);
+		ctx->label = aa_get_label(label);
 	}
 	aa_put_label(label);
 
@@ -1545,42 +1469,27 @@
 	struct aa_sk_ctx *a_ctx = aa_sock(socka->sk);
 	struct aa_sk_ctx *b_ctx = aa_sock(sockb->sk);
 	struct aa_label *label;
+	int error = 0;
+
+	aa_put_label(a_ctx->label);
+	aa_put_label(b_ctx->label);
 
-	/* socks not live yet - initial values set in sk_alloc */
 	label = begin_current_label_crit_section();
-	if (rcu_access_pointer(a_ctx->label) != label) {
-		AA_BUG("a_ctx != label");
-		aa_put_label(rcu_dereference_protected(a_ctx->label, true));
-		rcu_assign_pointer(a_ctx->label, aa_get_label(label));
-	}
-	if (rcu_access_pointer(b_ctx->label) != label) {
-		AA_BUG("b_ctx != label");
-		aa_put_label(rcu_dereference_protected(b_ctx->label, true));
-		rcu_assign_pointer(b_ctx->label, aa_get_label(label));
-	}
+	a_ctx->label = aa_get_label(label);
+	b_ctx->label = aa_get_label(label);
 
 	if (socka->sk->sk_family == PF_UNIX) {
 		/* unix socket pairs by-pass unix_stream_connect */
-		unix_connect_peers(a_ctx, b_ctx);
+		if (!error)
+			unix_connect_peers(a_ctx, b_ctx);
 	}
 	end_current_label_crit_section(label);
 
-	return 0;
+	return error;
 }
 
 /**
  * apparmor_socket_bind - check perms before bind addr to socket
- * @sock: socket to bind the address to (must be non-NULL)
- * @address: address that is being bound (must be non-NULL)
- * @addrlen: length of @address
- *
- * Performs security checks before allowing a socket to bind to an address.
- * Handles Unix domain sockets specially through aa_unix_bind_perm().
- * For other socket families, uses generic permission check via aa_sk_perm().
- *
- * Return:
- *   0 if binding is permitted
- *   error code on denial or invalid parameters
  */
 static int apparmor_socket_bind(struct socket *sock,
 				struct sockaddr *address, int addrlen)
@@ -1766,7 +1675,6 @@
 static int apparmor_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
 	struct aa_sk_ctx *ctx = aa_sock(sk);
-	int error;
 
 	if (!aa_secmark() || !skb->secmark)
 		return 0;
@@ -1775,15 +1683,11 @@
 	 * If reach here before socket_post_create hook is called, in which
 	 * case label is null, drop the packet.
 	 */
-	if (!rcu_access_pointer(ctx->label))
+	if (!ctx->label)
 		return -EACCES;
 
-	rcu_read_lock();
-	error = apparmor_secmark_check(rcu_dereference(ctx->label), OP_RECVMSG,
-				       AA_MAY_RECEIVE, skb->secmark, sk);
-	rcu_read_unlock();
-
-	return error;
+	return apparmor_secmark_check(ctx->label, OP_RECVMSG, AA_MAY_RECEIVE,
+				      skb->secmark, sk);
 }
 #endif
 
@@ -1793,8 +1697,8 @@
 	struct aa_sk_ctx *ctx = aa_sock(sk);
 	struct aa_label *label = ERR_PTR(-ENOPROTOOPT);
 
-	if (rcu_access_pointer(ctx->peer))
-		return aa_get_label_rcu(&ctx->peer);
+	if (ctx->peer)
+		return aa_get_label(ctx->peer);
 
 	if (sk->sk_family != PF_UNIX)
 		return ERR_PTR(-ENOPROTOOPT);
@@ -1821,12 +1725,12 @@
 	struct aa_label *label;
 	struct aa_label *peer;
 
+	label = begin_current_label_crit_section();
 	peer = sk_peer_get_label(sock->sk);
 	if (IS_ERR(peer)) {
 		error = PTR_ERR(peer);
 		goto done;
 	}
-	label = begin_current_label_crit_section();
 	slen = aa_label_asxprint(&name, labels_ns(label), peer,
 				 FLAG_SHOW_MODE | FLAG_VIEW_SUBNS |
 				 FLAG_HIDDEN_UNCONFINED, GFP_KERNEL);
@@ -1847,9 +1751,9 @@
 		error = -EFAULT;
 
 done_put:
-	end_current_label_crit_section(label);
 	aa_put_label(peer);
 done:
+	end_current_label_crit_section(label);
 	kfree(name);
 	return error;
 }
@@ -1885,9 +1789,8 @@
 {
 	struct aa_sk_ctx *ctx = aa_sock(sk);
 
-	/* setup - not live */
-	if (!rcu_access_pointer(ctx->label))
-		rcu_assign_pointer(ctx->label, aa_get_current_label());
+	if (!ctx->label)
+		ctx->label = aa_get_current_label();
 }
 
 #ifdef CONFIG_NETWORK_SECMARK
@@ -1895,17 +1798,12 @@
 				      struct request_sock *req)
 {
 	struct aa_sk_ctx *ctx = aa_sock(sk);
-	int error;
 
 	if (!aa_secmark() || !skb->secmark)
 		return 0;
 
-	rcu_read_lock();
-	error = apparmor_secmark_check(rcu_dereference(ctx->label), OP_CONNECT,
-				       AA_MAY_CONNECT, skb->secmark, sk);
-	rcu_read_unlock();
-
-	return error;
+	return apparmor_secmark_check(ctx->label, OP_CONNECT, AA_MAY_CONNECT,
+				      skb->secmark, sk);
 }
 #endif
 
@@ -1978,7 +1876,6 @@
 	LSM_HOOK_INIT(getprocattr, apparmor_getprocattr),
 	LSM_HOOK_INIT(setprocattr, apparmor_setprocattr),
 
-	LSM_HOOK_INIT(sk_alloc_security, apparmor_sk_alloc_security),
 	LSM_HOOK_INIT(sk_free_security, apparmor_sk_free_security),
 	LSM_HOOK_INIT(sk_clone_security, apparmor_sk_clone_security),
 
@@ -2671,7 +2568,6 @@
 {
 	struct aa_sk_ctx *ctx;
 	struct sock *sk;
-	int error;
 
 	if (!aa_secmark() || !skb->secmark)
 		return NF_ACCEPT;
@@ -2681,11 +2577,8 @@
 		return NF_ACCEPT;
 
 	ctx = aa_sock(sk);
-	rcu_read_lock();
-	error = apparmor_secmark_check(rcu_dereference(ctx->label), OP_SENDMSG,
-				       AA_MAY_SEND, skb->secmark, sk);
-	rcu_read_unlock();
-	if (!error)
+	if (!apparmor_secmark_check(ctx->label, OP_SENDMSG, AA_MAY_SEND,
+				    skb->secmark, sk))
 		return NF_ACCEPT;
 
 	return NF_DROP_ERR(-ECONNREFUSED);
@@ -2742,12 +2635,12 @@
 __initcall(apparmor_nf_ip_init);
 #endif
 
-static char nulldfa_src[] __aligned(8) = {
+static char nulldfa_src[] = {
 	#include "nulldfa.in"
 };
 static struct aa_dfa *nulldfa;
 
-static char stacksplitdfa_src[] __aligned(8) = {
+static char stacksplitdfa_src[] = {
 	#include "stacksplitdfa.in"
 };
 struct aa_dfa *stacksplitdfa;
diff -u a/security/apparmor/match.c b/security/apparmor/match.c
--- a/security/apparmor/match.c	2025-09-29 17:33:37.041574841 +0000
+++ b/security/apparmor/match.c	2025-10-03 07:27:33.794849305 +0000
@@ -679,35 +679,34 @@
 	return state;
 }
 
-#define inc_wb_pos(wb)							\
-do {									\
-	BUILD_BUG_ON_NOT_POWER_OF_2(WB_HISTORY_SIZE);			\
+#define inc_wb_pos(wb)						\
+do {								\
 	wb->pos = (wb->pos + 1) & (WB_HISTORY_SIZE - 1);		\
-	wb->len = (wb->len + 1) > WB_HISTORY_SIZE ? WB_HISTORY_SIZE :	\
-				wb->len + 1;				\
+	wb->len = (wb->len + 1) & (WB_HISTORY_SIZE - 1);		\
 } while (0)
 
 /* For DFAs that don't support extended tagging of states */
-/* adjust is only set if is_loop returns true */
 static bool is_loop(struct match_workbuf *wb, aa_state_t state,
 		    unsigned int *adjust)
 {
-	int pos = wb->pos;
-	int i;
+	aa_state_t pos = wb->pos;
+	aa_state_t i;
 
 	if (wb->history[pos] < state)
 		return false;
 
-	for (i = 0; i < wb->len; i++) {
+	for (i = 0; i <= wb->len; i++) {
 		if (wb->history[pos] == state) {
 			*adjust = i;
 			return true;
 		}
-		/* -1 wraps to WB_HISTORY_SIZE - 1 */
-		pos = (pos - 1) & (WB_HISTORY_SIZE - 1);
+		if (pos == 0)
+			pos = WB_HISTORY_SIZE;
+		pos--;
 	}
 
-	return false;
+	*adjust = i;
+	return true;
 }
 
 static aa_state_t leftmatch_fb(struct aa_dfa *dfa, aa_state_t start,
diff -u a/security/apparmor/net.c b/security/apparmor/net.c
--- a/security/apparmor/net.c	2025-09-29 17:33:37.042574889 +0000
+++ b/security/apparmor/net.c	2025-10-03 07:27:33.794849305 +0000
@@ -106,15 +106,10 @@
 {
 	const struct unix_sock *u = unix_sk(sk);
 
-	if (u && u->addr) {
-		int addrlen;
-		struct sockaddr_un *addr = aa_sunaddr(u, &addrlen);
-
-		audit_unix_addr(ab, str, addr, addrlen);
-	} else {
+	if (u && u->addr)
+		audit_unix_addr(ab, str, u->addr->name, u->addr->len);
+	else
 		audit_unix_addr(ab, str, NULL, 0);
-
-	}
 }
 
 /* audit callback for net specific fields */
@@ -149,16 +144,20 @@
 		}
 	}
 	if (ad->common.u.net->family == PF_UNIX) {
-		if (ad->net.addr || !ad->common.u.net->sk)
+		if ((ad->request & ~NET_PEER_MASK) && ad->net.addr)
 			audit_unix_addr(ab, "addr",
 					unix_addr(ad->net.addr),
 					ad->net.addrlen);
 		else
 			audit_unix_sk_addr(ab, "addr", ad->common.u.net->sk);
 		if (ad->request & NET_PEER_MASK) {
-			audit_unix_addr(ab, "peer_addr",
-					unix_addr(ad->net.peer.addr),
-					ad->net.peer.addrlen);
+			if (ad->net.addr)
+				audit_unix_addr(ab, "peer_addr",
+						unix_addr(ad->net.addr),
+						ad->net.addrlen);
+			else
+				audit_unix_sk_addr(ab, "peer_addr",
+						   ad->net.peer_sk);
 		}
 	}
 	if (ad->peer) {
@@ -318,7 +317,7 @@
 	AA_BUG(!label);
 	AA_BUG(!sk);
 
-	if (rcu_access_pointer(ctx->label) != kernel_t && !unconfined(label)) {
+	if (ctx->label != kernel_t && !unconfined(label)) {
 		struct aa_profile *profile;
 		DEFINE_AUDIT_SK(ad, op, subj_cred, sk);
 
diff -u a/security/apparmor/notify.c b/security/apparmor/notify.c
--- a/security/apparmor/notify.c	2025-09-29 17:33:37.042574889 +0000
+++ b/security/apparmor/notify.c	2025-10-03 07:27:33.794849305 +0000
@@ -11,7 +11,6 @@
  * published by the Free Software Foundation, version 2 of the
  * License.
  */
-#include <linux/align.h>
 #include <linux/ctype.h>
 #include <linux/utsname.h>
 #include <linux/poll.h>
@@ -22,27 +21,8 @@
 #include "include/cred.h"
 #include "include/lib.h"
 #include "include/notify.h"
-#include "include/policy.h"
 #include "include/policy_ns.h"
 
-
-
-static DEFINE_SPINLOCK(notif_lock);
-static u64 g_listener_id = 1;
-
-static u64 get_next_listener_id(void)
-{
-	u64 tmp;
-
-	spin_lock(&notif_lock);
-	tmp = ++g_listener_id;
-	spin_unlock(&notif_lock);	
-
-	return tmp;
-}
-
-/*****************************************************************/
-
 /* TODO: when adding listener or ns propagate, on recursive add to child ns */
 
 // TODO: currently all knotif will have audit_node but not all in future
@@ -129,24 +109,18 @@
 
 void aa_free_listener_proxy(struct aa_listener_proxy *proxy)
 {
-	if (proxy->listener) {
-		spin_lock(&proxy->listener->lock);
-		list_del_init(&proxy->llist);
-		spin_unlock(&proxy->listener->lock);
-	}
-	if (proxy->ns) {
-		spin_lock(&proxy->ns->listener_lock);
-		list_del_init(&proxy->nslist);
-		spin_unlock(&proxy->ns->listener_lock);
+	if (proxy) {
+		AA_BUG(!list_empty(&proxy->llist));
+		AA_BUG(!list_empty(&proxy->nslist));
+
+		aa_put_ns(proxy->ns);
+		/* listener is owned by file, handled there */
+		kfree_sensitive(proxy);
 	}
-	aa_put_ns(proxy->ns);
-	aa_put_listener(proxy->listener);
-	kfree_sensitive(proxy);
 }
 
-// transfers listeners refcount
-struct aa_listener_proxy *aa_new_listener_proxy(struct aa_listener *listener,
-						struct aa_ns *ns)
+static struct aa_listener_proxy *new_listener_proxy(struct aa_listener *listener,
+						   struct aa_ns *ns)
 {
 	struct aa_listener_proxy *proxy;
 
@@ -159,7 +133,7 @@
 	INIT_LIST_HEAD(&proxy->llist);
 	INIT_LIST_HEAD(&proxy->nslist);
 
-	proxy->listener = aa_get_listener(listener);
+	proxy->listener = listener;
 	if (ns)
 		ns = aa_get_ns(ns);
 	else
@@ -174,16 +148,28 @@
 	list_add_tail_entry(proxy, &ns->listeners, nslist);
 	spin_unlock(&ns->listener_lock);
 
-	AA_DEBUG(DEBUG_UPCALL, "Added new listener proxy for listener %lld", listener->listener_id);
 	return proxy;
 }
 
+
+bool aa_register_listener_proxy(struct aa_listener *listener, struct aa_ns *ns)
+{
+	struct aa_listener_proxy *proxy;
+
+	AA_BUG(!listener);
+
+	proxy = new_listener_proxy(listener, ns);
+	if (!proxy)
+		return false;
+
+	return true;
+}
+
 static void free_listener(struct aa_listener *listener)
 {
 	struct aa_listener_proxy *proxy;
 	struct aa_knotif *knotif;
 
-	AA_DEBUG(DEBUG_UPCALL, "enter freeing listener_id %llu", listener->listener_id);
 	if (!listener)
 		return;
 
@@ -233,9 +219,7 @@
 	/* todo count on audit_data */
 	aa_put_ns(listener->ns);
 	aa_put_dfa(listener->filter);
-	aa_put_label(listener->label);
 
-	AA_DEBUG(DEBUG_UPCALL, "freeing listener_id %llu", listener->listener_id);
 	kfree_sensitive(listener);
 }
 
@@ -243,45 +227,16 @@
 {
 	struct aa_listener *l = container_of(kref, struct aa_listener, count);
 
-	AA_DEBUG(DEBUG_UPCALL, "going to free listener %p, label %p, id %llu", l, l->label, l->listener_id);
 	free_listener(l);
 }
 
-#define from_delayed_work(var, callback_work, work_fieldname)	\
-	container_of(to_delayed_work(callback_work), typeof(*var), work_fieldname)
-
-static void proxy_work_function(struct work_struct *t)
-{
-	struct aa_listener_proxy *proxy = from_delayed_work(proxy, t, work);
-	AA_DEBUG(DEBUG_UPCALL, "listener reclaim timer fired. Putting listener %llu", proxy->listener->listener_id);
-	aa_free_listener_proxy(proxy);
-	/* don't want to remove here because may have been reclaimed */
-	//aa_put_listener(proxy->listener);
-}
-
-
-//unsigned long seconds = 1;
-void aa_delayed_free_listener_proxy(struct aa_listener_proxy *proxy)
-{
-	memset(&proxy->work, 0, sizeof(proxy->work));
-
-	AA_DEBUG(DEBUG_UPCALL, "before timer listener %p listener_id %llu label %p", proxy->listener, proxy->listener->listener_id, proxy->listener->label);
-
-	/* delay putting the listener giving a chance to reclaim */
-	INIT_DELAYED_WORK(&proxy->work, proxy_work_function);
-	schedule_delayed_work(&proxy->work, secs_to_jiffies(30));
-
-	AA_DEBUG(DEBUG_UPCALL, "after timer listener %p listener_id %llu label %p", proxy->listener, proxy->listener->listener_id, proxy->listener->label);
-}
-
 struct aa_listener *aa_new_listener(struct aa_ns *ns, gfp_t gfp)
 {
 	struct aa_listener *listener = kzalloc(sizeof(*listener), gfp);
 
 	if (!listener)
 		return NULL;
-	AA_DEBUG(DEBUG_UPCALL, "listener %p", listener);
-	
+
 	kref_init(&listener->count);
 	spin_lock_init(&listener->lock);
 	init_waitqueue_head(&listener->wait);
@@ -296,87 +251,10 @@
 		ns = aa_get_current_ns();
 	listener->ns = ns;
 	listener->last_id = 1;
-	listener->listener_id = get_next_listener_id();
-
-	AA_DEBUG(DEBUG_UPCALL, "created listener %lld ns %p", listener->listener_id, ns);
-	return listener;
-}
-
-/* increments proxy->listener ref count
-* can still be on list because file callback to cleanup is delayed
-*/
-static struct aa_listener *find_matching_listener_by_id(struct aa_ns *ns,
-							u64 id)
-{
-	struct aa_listener *listener = NULL;
-	struct aa_listener_proxy *proxy = NULL;
-
-	spin_lock(&ns->listener_lock);
-	list_for_each_entry(proxy, &ns->listeners, nslist) {
-		AA_DEBUG(DEBUG_UPCALL, "   comparing listener %p label %p id %llu to %llu", proxy->listener, proxy->listener->label, proxy->listener->listener_id, id);
-		spin_lock(&proxy->listener->lock);
-		if (proxy->listener->listener_id == id) {
-			listener = aa_get_listener(proxy->listener);
-			spin_unlock(&proxy->listener->lock);
-			AA_DEBUG(DEBUG_UPCALL, "      found listener %p label %p id %llu to %llu", listener, listener->label, listener->listener_id, id);
-			break;
-		}
-		spin_unlock(&proxy->listener->lock);
-	}
-	spin_unlock(&ns->listener_lock);
 
 	return listener;
 }
 
-/* attempt to register a listener. If id is 0 get a new id else find
- * existing listener
- */
-long aa_register_listener_id(struct aa_listener *listener, u64 *id,
-			     struct aa_listener **found)
-{
-	struct aa_label *label;
-	int error = 0;
-
-	AA_BUG(!listener);
-	AA_BUG(!id);
-
-	*found = NULL;
-
-	label = begin_current_label_crit_section();
-	if (*id == 0) {
-		spin_lock(&listener->ns->listener_lock);
-		if (listener->label) {
-			if (listener->label == label) {
-				*id = listener->listener_id;
-			} else {
-				error = -EPERM;
-			}
-		} else {
-			listener->label = aa_get_label(label);
-			*id = listener->listener_id;
-			AA_DEBUG(DEBUG_UPCALL, "assigned label %p to listener %p listener->label %p id %llu", label, listener, listener->label, listener->listener_id);
-		}
-		spin_unlock(&listener->ns->listener_lock);
-	} else {
-		struct aa_listener *tmp = find_matching_listener_by_id(listener->ns, *id);
-		if (tmp) {
-			if (tmp->label != label) {
-				AA_DEBUG(DEBUG_UPCALL, "confinement for listener %p id %llu search id %llu, listener->label %p != label %p", tmp, tmp->listener_id, *id, tmp->label , label);
-				aa_put_listener(tmp);
-				error = -EPERM;
-			} else {
-				*found = tmp;
-			}
-		} else {
-			AA_DEBUG(DEBUG_UPCALL, "  no listener found");
-			error = -ENOENT;
-		}
-	}
-	end_current_label_crit_section(label);
-
-	return error;
-}
-
 static struct aa_knotif *__aa_find_notif_pending(struct aa_listener *listener,
 						 u64 id)
 {
@@ -412,7 +290,6 @@
 }
 
 // don't drop refcounts
-/* TODO: replace use of pop/push with more correct append or enqueue/dequeue */
 static struct aa_knotif *
 listener_pop_and_hold_knotif(struct aa_listener *listener)
 {
@@ -488,10 +365,8 @@
 static bool notification_match(struct aa_listener *listener,
 			       struct aa_audit_node *ad)
 {
-	if (!(listener->mask & (1 << ad->data.type))) {
-		AA_DEBUG(DEBUG_UPCALL, "listener mask failed 0x%x, type %d", listener->mask, ad->data.type);
+	if (!(listener->mask & (1 << ad->data.type)))
 		return false;
-	}
 
 	if (listener->filter) {
 		aa_state_t state;
@@ -516,7 +391,6 @@
 		 *	// TODO: match extensions
 		 * }
 		 */
-		AA_DEBUG(DEBUG_UPCALL, "failed filter match");
 		return false;
 	}
 	AA_DEBUG(DEBUG_UPCALL, "matched type mask filter");
@@ -524,7 +398,8 @@
 }
 
 /* Add a notification to the listener queue and wake up listener??? */
-static void dispatch_notif(struct aa_listener *listener, u16 ntype,
+static void dispatch_notif(struct aa_listener *listener,
+			   u16 ntype,
 			   struct aa_knotif *knotif)
 {
 	AA_BUG(!listener);
@@ -532,8 +407,8 @@
 	lockdep_assert_held(&listener->lock);
 
 	AA_DEBUG_ON(knotif->id, DEBUG_UPCALL,
-		    "dispatching notification as new id %lld",
-		    listener->last_id);
+		    "id %lld: redispatching notification as new id %lld",
+		    knotif->id, listener->last_id);
 	knotif->ntype = ntype;
 	knotif->id = ++listener->last_id;
 	knotif->flags = 0;
@@ -628,14 +503,13 @@
 		listener = aa_get_listener(proxy->listener);
 		AA_BUG(!listener);
 		spin_lock(&listener->lock);
-		AA_DEBUG(DEBUG_UPCALL, "checking listener %lld for match", listener->listener_id);
 		if (!notification_match(listener, node)) {
 			spin_unlock(&listener->lock);
 			aa_put_listener(listener);
 			continue;
 		}
 		/* delvier notification - dispatch determines if we break */
-		dispatch_notif(listener, ntype, knotif);
+		dispatch_notif(listener, ntype, knotif); // count);
 		spin_unlock(&listener->lock);
 		AA_DEBUG(DEBUG_UPCALL, "id %lld: found listener\n",
 			 knotif->id);
@@ -660,37 +534,6 @@
 	return err;
 }
 
-long aa_listener_unotif_resend(struct aa_listener *listener, u32 *ready,
-			       u32 *pending)
-{
-	struct aa_knotif *knotif;
-	*ready = 0;
-	*pending = 0;
-
-	spin_lock(&listener->ns->listener_lock);
-	list_for_each_entry(knotif, &listener->notifications, list) {
-		(*ready)++;
-	}
-	list_for_each_entry(knotif, &listener->pending, list) {
-		knotif->flags = KNOTIF_RESEND;
-		AA_DEBUG_ON(knotif->id, DEBUG_UPCALL,
-			    "redispatching notification id %lld",
-			    knotif->id);
-		(*pending)++;
-	}
-	/* splice is like stack to move pending onto of notification
-	 * but pulled from head like queue. ie pending is moving
-	 * to the front of the queue.
-	 */
-	list_splice_init(&listener->pending, &listener->notifications);
-	AA_DEBUG(DEBUG_UPCALL, "id %lld: %s wake_up_interruptible",
-		 knotif->id, __func__);
-	wake_up_interruptible_poll(&listener->wait, EPOLLIN | EPOLLRDNORM);
-	spin_unlock(&listener->ns->listener_lock);
-
-	return 0;
-}
-
 /******************** task responding to notification **********************/
 
 // drop references
@@ -1057,9 +900,13 @@
 
 /******************** task reading notification to userspace ****************/
 
-static long append_bytes(void __user *pos, long remaining, const char *str,
-			 u32 size)
+static long append_str(void __user *pos, long remaining, const char *str)
 {
+	long size;
+
+	if (!str)
+		return 0;
+	size = strlen(str) + 1;
 	if (size > remaining)
 		return -EMSGSIZE;
 	if (copy_to_user(pos, str, size))
@@ -1068,223 +915,75 @@
 	return size;
 }
 
-/* __POS will be updated
- *  __FIELD will be updated
- *  returns __SIZE or error
- */
-#define build_append_bytes(__BUF, __POS, __MAX, __STR, __SIZE, __FIELD)	\
+#define build_append_str(__BUF, __POS, __MAX, __STR, __FIELD, __SIZE)	\
 ({									\
-	long __tmp_size;						\
-	long __tmp_offset = __POS - __BUF;				\
-	__tmp_size = append_bytes(__POS, __MAX - __tmp_offset, __STR, __SIZE); \
+	typeof(__SIZE) __tmp_size;					\
+	__FIELD = __POS - __BUF;					\
+	__tmp_size = append_str(__POS, max_size - (__POS - __BUF), __STR); \
 	if (__tmp_size >= 0) {						\
-		__FIELD = __tmp_offset;					\
 		__POS += __tmp_size;					\
+		__SIZE += __tmp_size;					\
+	} else {							\
+		__SIZE = __tmp_size;					\
 	}								\
-	(__tmp_size);							\
+	(__tmp_size >= 0);						\
 })
 
-/* __POS will be updated
- *  __FIELD will be updated
- *  returns __SIZE or error
- */
-#define build_append_str(__BUF, __POS, __MAX, __STR, __FIELD)		\
-({									\
-	long __tmp_size = 0;						\
-	if (__STR) {							\
-		__tmp_size = build_append_bytes(__BUF, __POS, __MAX, __STR, \
-						strlen(__STR)+1, __FIELD);\
-	}								\
-	(__tmp_size);							\
-})
-
-/* returns amount written to tpos */
-static long build_tagset(void __user *buf, void __user *hpos, void __user *tpos,
-			 u16 max_size, u32 mask, u32 count, const char *tagstr,
-			 u32 tagsize)
-{
-	struct apparmor_tags_header_v5 th;
-	long size;
-
-	th.mask = mask;
-	th.count = count;
-	th.tagset = tpos - buf;
-	size = build_append_bytes(buf, tpos, max_size, tagstr, tagsize,
-				  th.tagset);
-	if (size < 0) {
-		AA_DEBUG(DEBUG_TAGS, "build_append_bytes %ld < 0, max %d, tagstr '%s', (long) pos %d, size %d", size, max_size, tagstr, th.tagset, tagsize);
-		return size;
-	}
-	AA_DEBUG(DEBUG_TAGS, "      tagset: mask 0x%x, count %d, pos %d, str '%s', strlen %ld, size %ld, return size %ld\n", mask, count, th.tagset, tagstr, strlen(tagstr), (long) tagsize, size);
-	if (copy_to_user(hpos, &th, sizeof(th))) {
-		AA_DEBUG(DEBUG_TAGS, "failed: copy_to_user hpos %ld", (long) hpos);
-		return -EFAULT;
-	}
-	return size;
-}
-
-/* build tags for a given tag index */
-static long build_tags(union apparmor_notif_all *unotif,
-		       void __user *buf, void __user *pos, u16 max_size,
-		       struct aa_tags_struct *metatags, u32 mask, u32 permidx)
-{
-	void __user *hpos, *tpos;
-	int i, c = 0;
-
-	if (!metatags || permidx == 0)
-		return pos - buf;
-
-	/* count number of header that need to be laid down */
-	for (i = 0; i < metatags->sets.table[permidx]; i++) {
-		u32 idx = metatags->sets.table[permidx+1+i];
-		if (mask & metatags->hdrs.table[idx].mask) {
-			c++;
-			AA_DEBUG(DEBUG_TAGS, "matched mask 0x%x, tag[%d].mask 0x%x\n", mask, i, metatags->hdrs.table[idx].mask);
-		}
-	}
-	if (c == 0) {
-		AA_DEBUG(DEBUG_TAGS, "No matching tag info");
-		/* no tags match */
-		return pos - buf;
-	}
-
-	hpos = PTR_ALIGN(pos, 8);
-	tpos = hpos + (c * sizeof(struct apparmor_tags_header_v5)); //c * 96
-
-	unotif->file.tags = hpos - buf;
-	unotif->file.tags_count = c;
-	AA_DEBUG(DEBUG_TAGS,
-		 "file tags header hpos %ld, tpos %ld tagset_count %d",
-		 hpos - buf, tpos- buf, c);
-	for (i = 0; i < metatags->sets.table[permidx]; i++) {
-		u32 idx = metatags->sets.table[permidx+1+i];
-		AA_DEBUG(DEBUG_TAGS,
-		    "  ... building loop %d, idx %d, mask 0x%x, tags mask 0x%x",
-			 i, idx, mask, metatags->hdrs.table[idx].mask);
-		if (mask & metatags->hdrs.table[idx].mask) {
-			struct aa_tags_header *h = &metatags->hdrs.table[idx];
-			long size;
-
-			AA_DEBUG(DEBUG_TAGS,
-			   "   build_tagset hpos %ld, tpos %ld, index tagset %d tagstr '%s'",
-				 hpos - buf, tpos - buf, h->tags,
-				 metatags->strs.table[h->tags].strs);
-			size = build_tagset(buf, hpos, tpos, max_size,
-					    h->mask, h->count,
-					    metatags->strs.table[h->tags].strs,
-					    h->size);
-			if (size < 0) {
-				AA_DEBUG(DEBUG_TAGS, "build_tagset failed");
-				return size;
-			}
-			hpos += sizeof(struct apparmor_tags_header_v5);
-			tpos += size;
-		} else
-			AA_DEBUG(DEBUG_TAGS, "   no build tagset %d",
-				 mask & metatags->hdrs.table[idx].mask);
-	}
-
-	AA_DEBUG(DEBUG_TAGS,
-		 "   build_tags completed pos %ld, buf %ld, size %ld",
-		 (long) tpos, (long) buf, tpos-buf);
-	return tpos - buf;
-}
-
-static long build_v35_unotif_common(struct aa_profile *profile,
-				   u16 version,
-				   struct aa_knotif *knotif,
-				   union apparmor_notif_all *unotif,
-				   void __user *buf, u16 max_size)
+/* copy to userspace: notification data */
+static long build_v3_unotif(struct aa_knotif *knotif, void __user *buf,
+			    u16 max_size)
 {
+	union apparmor_notif_all unotif = { };
 	struct user_namespace *user_ns;
+	struct aa_profile *profile;
+	void __user *pos;
+	long size;
 
 	AA_DEBUG(DEBUG_UPCALL, "building notif max size %d", max_size);
-	if (sizeof(*unotif) > max_size)
+	size = sizeof(unotif);
+	profile = labels_profile(knotif->ad->subj_label);
+	AA_BUG(profile == NULL);
+	if (size > max_size)
 		return -EMSGSIZE;
 
 	user_ns = get_user_ns(current->nsproxy->uts_ns->user_ns);
 
 	/* build response */
-	unotif->common.len = sizeof(*unotif);
-	unotif->common.version = version;
-	unotif->base.ntype = knotif->ntype;
-	if (knotif->flags & KNOTIF_RESEND)
-		unotif->base.flags |= UNOTIF_RESENT;
-	unotif->base.id = knotif->id;
-	unotif->base.error = knotif->ad->error;
-	unotif->op.allow = knotif->ad->request & ~knotif->ad->denied;
-	unotif->op.deny = knotif->ad->denied;
+	unotif.common.len = size;
+	unotif.common.version = APPARMOR_NOTIFY_VERSION;
+	unotif.base.ntype = knotif->ntype;
+	unotif.base.id = knotif->id;
+	unotif.base.error = knotif->ad->error;
+	unotif.op.allow = knotif->ad->request & ~knotif->ad->denied;
+	unotif.op.deny = knotif->ad->denied;
 	AA_DEBUG(DEBUG_UPCALL,
 		 "notif %lld: sent to user read request 0x%x, denied 0x%x, error %d",
 		 knotif->id, knotif->ad->request, knotif->ad->denied, knotif->ad->error);
 
 	if (knotif->ad->subjtsk != NULL) {
-		unotif->op.pid = task_pid_vnr(knotif->ad->subjtsk);
-		unotif->file.subj_uid = from_kuid(user_ns, task_uid(knotif->ad->subjtsk));
+		unotif.op.pid = task_pid_vnr(knotif->ad->subjtsk);
+		unotif.file.subj_uid = from_kuid(user_ns, task_uid(knotif->ad->subjtsk));
 	}
-	unotif->op.class = knotif->ad->class;
-	unotif->file.obj_uid = from_kuid(user_ns, knotif->ad->fs.ouid);
+	unotif.op.class = knotif->ad->class;
+	unotif.file.obj_uid = from_kuid(user_ns, knotif->ad->fs.ouid);
 
 	put_user_ns(user_ns);
 
-	return sizeof(*unotif);
-}
-
-/* returns total size */
-static long build_v35_unotif_file(struct aa_profile *profile,
-				 struct aa_knotif *knotif,
-				 union apparmor_notif_all *unotif,
-				 void __user *buf, long size, u16 max_size)
-{
-	void __user *pos = buf + size;
-	size = build_append_str(buf, pos, max_size, profile->base.hname,
-				unotif->op.label);
-	if (size < 0)
-		return size;
-	size = build_append_str(buf, pos, max_size, knotif->ad->name,
-				unotif->file.name);
-	if (size < 0)
-		return size;
-
-	if (unotif->common.version == 5) {
-		struct aa_ruleset *rules = profile->label.rules[0];
-		size = build_tags(unotif, buf, pos, max_size, &rules->file->tags,
-				  knotif->ad->request | knotif->ad->denied,
-				  knotif->ad->tags);
-		if (size < 0)
-			return size;
-		pos = buf + size;
-	}
-	return pos - buf;
-}
-
-/* copy to userspace: notification data */
-static long build_v35_unotif(u16 version, struct aa_knotif *knotif,
-			     void __user *buf, u16 max_size)
-{
-	union apparmor_notif_all unotif = { };
-	struct aa_profile *profile;
-	long size;
-
-	profile = labels_profile(knotif->ad->subj_label);
-	AA_BUG(profile == NULL);
-
-	size = build_v35_unotif_common(profile, version, knotif, &unotif, buf,
-				       max_size);
-	if (size < 0)
-		return size;
-	size = build_v35_unotif_file(profile, knotif, &unotif, buf, size,
-				     max_size);
-	if (size < 0)
-		return size;
+	pos = buf + sizeof(unotif);
+	if (!build_append_str(buf, pos, max_size, profile->base.hname,
+			      unotif.op.label, size))
+		return -EMSGSIZE;
+	if (!build_append_str(buf, pos, max_size, knotif->ad->name,
+			      unotif.file.name, size))
+		return -EMSGSIZE;
 
-	/* set size after appending variable length info */
+	/* set size after appending strings */
 	unotif.common.len = size;
 	/* now the struct, at the start of user mem */
 	if (copy_to_user(buf, &unotif, sizeof(unotif)))
 		return -EFAULT;
 
-	return size;
+	return pos - buf;
 }
 
 // return < 0 == error
@@ -1292,26 +991,19 @@
 //        > 0 == built notification successfully
 static long build_mediation_unotif(struct aa_listener *listener,
 				   struct aa_knotif *knotif,
-				   void __user *buf, u16 max_size,
-				   u16 version)
+				   void __user *buf, u16 max_size)
 {
 	long ret;
 
 	switch (knotif->ad->class) {
 	case AA_CLASS_FILE:
-		if (listener->version == APPARMOR_NOTIFY_V3 ||
-		    listener->version == APPARMOR_NOTIFY_V5) {
-			ret = build_v35_unotif(listener->version, knotif,
-					       buf, max_size);
-			if (ret < 0) {
-				AA_DEBUG(DEBUG_UPCALL,
+		ret = build_v3_unotif(knotif, buf, max_size);
+		if (ret < 0) {
+			AA_DEBUG(DEBUG_UPCALL,
 				 "id %lld: (error=%ld) failed to copy data to user reading size %ld, maxsize %d",
-					 knotif->id, ret,
-					 sizeof(union apparmor_notif_all), max_size);
-				goto out;
-			}
-		} else {
-			ret = -EPROTONOSUPPORT;
+				 knotif->id, ret,
+				 sizeof(union apparmor_notif_all), max_size);
+			goto out;
 		}
 		break;
 	default:
@@ -1327,7 +1019,7 @@
 /* Handle the listener reading a notification into userspace */
 // TODO: output multiple messages in one recv
 long aa_listener_unotif_recv(struct aa_listener *listener, void __user *buf,
-			     u16 max_size, u16 version)
+			     u16 max_size)
 {
 	struct aa_knotif *knotif;
 	long ret;
@@ -1340,8 +1032,7 @@
 		AA_DEBUG(DEBUG_UPCALL, "id %lld: removed notif from listener queue",
 			 knotif->id);
 
-		ret = build_mediation_unotif(listener, knotif, buf, max_size,
-					     version);
+		ret = build_mediation_unotif(listener, knotif, buf, max_size);
 		if (ret < 0) {
 			/* failed - drop notif and return error to reader */
 			listener_complete_held_user_pending(listener, knotif);
diff -u a/security/apparmor/policy.c b/security/apparmor/policy.c
--- a/security/apparmor/policy.c	2025-10-03 07:37:49.883335212 +0000
+++ b/security/apparmor/policy.c	2025-10-03 07:27:33.794849305 +0000
@@ -102,21 +102,13 @@
 	"user",
 };
 
-void aa_destroy_tags(struct aa_tags_struct *tags)
-{
-	kfree_sensitive(tags->hdrs.table);
-	kfree_sensitive(tags->sets.table);
-	aa_destroy_str_table(&tags->strs);
-	memset(tags, 0, sizeof(*tags));
-}
 
 static void aa_free_pdb(struct aa_policydb *pdb)
 {
 	if (pdb) {
 		aa_put_dfa(pdb->dfa);
 		kvfree(pdb->perms);
-		aa_destroy_str_table(&pdb->trans);
-		aa_destroy_tags(&pdb->tags);
+		aa_free_str_table(&pdb->trans);
 		kfree(pdb);
 	}
 }
@@ -236,9 +228,6 @@
 {
 	struct aa_data *data = ptr;
 
-	if (!ptr)
-		return;
-
 	kvfree_sensitive(data->data, data->size);
 	kfree_sensitive(data->key);
 	kfree_sensitive(data);
@@ -248,9 +237,6 @@
 {
 	int i;
 
-	if (!attach)
-		return;
-
 	for (i = 0; i < attach->xattr_count; i++)
 		kfree_sensitive(attach->xattrs[i]);
 	kfree_sensitive(attach->xattrs);
@@ -261,9 +247,6 @@
 {
 	int i;
 
-	if (!rules)
-	  return;
-
 	aa_put_pdb(rules->file);
 	aa_put_pdb(rules->policy);
 	aa_free_cap_rules(&rules->caps);
@@ -326,9 +309,9 @@
 	 * at this point there are no tasks that can have a reference
 	 * to rules
 	 */
-	for (int i = 0; i < profile->n_rules; i++)
+	for (int i = 0; i < profile->n_rules; i++) {
 		free_ruleset(profile->label.rules[i]);
-
+	}
 	kfree_sensitive(profile->dirname);
 
 	if (profile->data) {
@@ -366,6 +349,7 @@
 	profile = kzalloc(struct_size(profile, label.rules, 1), gfp);
 	if (!profile)
 		return NULL;
+	profile->n_rules = 1;
 
 	if (!aa_policy_init(&profile->base, NULL, hname, gfp))
 		goto fail;
@@ -376,7 +360,6 @@
 	profile->label.rules[0] = aa_alloc_ruleset(gfp);
 	if (!profile->label.rules[0])
 		goto fail;
-	profile->n_rules = 1;
 
 	/* update being set needed by fs interface */
 	if (!proxy) {
@@ -910,11 +893,11 @@
 bool aa_current_policy_view_capable(struct aa_ns *ns)
 {
 	struct aa_label *label;
-	bool needput, res;
+	bool res;
 
-	label = __begin_current_label_crit_section(&needput);
+	label = __begin_current_label_crit_section();
 	res = aa_policy_view_capable(current_cred(), label, ns);
-	__end_current_label_crit_section(label, needput);
+	__end_current_label_crit_section(label);
 
 	return res;
 }
@@ -922,11 +905,11 @@
 bool aa_current_policy_admin_capable(struct aa_ns *ns)
 {
 	struct aa_label *label;
-	bool needput, res;
+	bool res;
 
-	label = __begin_current_label_crit_section(&needput);
+	label = __begin_current_label_crit_section();
 	res = aa_policy_admin_capable(current_cred(), label, ns);
-	__end_current_label_crit_section(label, needput);
+	__end_current_label_crit_section(label);
 
 	return res;
 }
diff -u a/security/apparmor/policy_compat.c b/security/apparmor/policy_compat.c
--- a/security/apparmor/policy_compat.c	2025-09-29 17:33:37.042574889 +0000
+++ b/security/apparmor/policy_compat.c	2025-10-03 07:27:33.794849305 +0000
@@ -267,10 +267,9 @@
 	*size = state_count;
 
 	/* zero init so skip the trap state (state == 0) */
-	for (state = 1; state < state_count; state++) {
+	for (state = 1; state < state_count; state++)
 		table[state] = compute_perms_entry(dfa, state, version);
-		AA_DEBUG(DEBUG_UNPACK, "[%d]: (0x%x/0x%x/0x%x//0x%x/0x%x//0x%x), converted from accept1: 0x%x, accept2: 0x%x", state, table[state].allow, table[state].deny, table[state].prompt, table[state].audit, table[state].quiet, table[state].xindex, ACCEPT_TABLE(dfa)[state], ACCEPT_TABLE2(dfa)[state]);
-	}
+
 	return table;
 }
 
diff -u a/security/apparmor/policy_unpack.c b/security/apparmor/policy_unpack.c
--- a/security/apparmor/policy_unpack.c	2025-09-29 17:33:37.042574889 +0000
+++ b/security/apparmor/policy_unpack.c	2025-10-03 07:27:33.795849348 +0000
@@ -463,70 +463,20 @@
 	return dfa;
 }
 
-static int process_strs_entry(char *str, int size, bool multi)
-{
-	int c = 1;
-
-	if (size <= 0)
-		return -1;
-	if (multi) {
-		if (size < 2)
-			return -2;
-		/* multi ends with double \0 */
-		if (str[size - 2])
-			return -3;
-	}
-
-char *save = str;
-	char *pos = str;
-	char *end = multi ? str + size - 2 : str + size - 1;
-	/* count # of internal \0 */
-	while (str < end) {
-		if (str == pos) {
-			/* starts with ... */
-			if (!*str)
-			{
-				AA_DEBUG(DEBUG_UNPACK, "starting with null save=%lu size %d c=%d", str - save, size, c);
-				return -4;
-			}
-			if (isspace(*str))
-				return -5;
-			if (*str == ':') {
-				/* :ns_str\0str\0
-				 * first character after : must be valid
-				 */
-				if (!str[1])
-					return -6;
-			}
-		} else if (!*str) {
-			if (*pos == ':')
-				*str = ':';
-			else
-				c++;
-			pos = str +  1;
-		}
-		str++;
-	} /* while */
-
-	return c;
-}
-
 /**
- * unpack_strss_table - unpack a profile transition table
+ * unpack_trans_table - unpack a profile transition table
  * @e: serialized data extent information  (NOT NULL)
- * @name: name of table (MAY BE NULL)
  * @strs: str table to unpack to (NOT NULL)
  *
  * Returns: true if table successfully unpacked or not present
  */
-static bool unpack_strs_table(struct aa_ext *e, const char *name, bool multi,
-			      struct aa_str_table *strs)
+static bool unpack_trans_table(struct aa_ext *e, struct aa_str_table *strs)
 {
 	void *saved_pos = e->pos;
-	struct aa_str_table_ent *table = NULL;
+	char **table = NULL;
 
 	/* exec table is optional */
-	if (aa_unpack_nameX(e, AA_STRUCT, name)) {
+	if (aa_unpack_nameX(e, AA_STRUCT, "xtable")) {
 		u16 size;
 		int i;
 
@@ -538,8 +488,7 @@
 			 * for size check here
 			 */
 			goto fail;
-		table = kcalloc(size, sizeof(struct aa_str_table_ent),
-				GFP_KERNEL);
+		table = kcalloc(size, sizeof(char *), GFP_KERNEL);
 		if (!table)
 			goto fail;
 
@@ -547,23 +496,41 @@
 		strs->size = size;
 		for (i = 0; i < size; i++) {
 			char *str;
-			int c, size2 = aa_unpack_strdup(e, &str, NULL);
+			int c, j, pos, size2 = aa_unpack_strdup(e, &str, NULL);
 			/* aa_unpack_strdup verifies that the last character is
 			 * null termination byte.
 			 */
-			c = process_strs_entry(str, size2, multi);
-			if (c <= 0) {
-				AA_DEBUG(DEBUG_UNPACK, "process_strs %d i %d pos %ld", c, i, e->pos - saved_pos);
+			if (!size2)
 				goto fail;
+			table[i] = str;
+			/* verify that name doesn't start with space */
+			if (isspace(*str))
+				goto fail;
+
+			/* count internal #  of internal \0 */
+			for (c = j = 0; j < size2 - 1; j++) {
+				if (!str[j]) {
+					pos = j;
+					c++;
+				}
 			}
-			if (!multi && c > 1) {
-				AA_DEBUG(DEBUG_UNPACK, "!multi && c > 1");
+			if (*str == ':') {
+				/* first character after : must be valid */
+				if (!str[1])
+					goto fail;
+				/* beginning with : requires an embedded \0,
+				 * verify that exactly 1 internal \0 exists
+				 * trailing \0 already verified by aa_unpack_strdup
+				 *
+				 * convert \0 back to : for label_parse
+				 */
+				if (c == 1)
+					str[pos] = ':';
+				else if (c > 1)
+					goto fail;
+			} else if (c)
 				/* fail - all other cases with embedded \0 */
 				goto fail;
-			}
-			table[i].strs = str;
-			table[i].count = c;
-			table[i].size = size2;
 		}
 		if (!aa_unpack_nameX(e, AA_ARRAYEND, NULL))
 			goto fail;
@@ -573,7 +540,7 @@
 	return true;
 
 fail:
-	aa_destroy_str_table(strs);
+	aa_free_str_table(strs);
 	e->pos = saved_pos;
 	return false;
 }
@@ -645,8 +612,8 @@
 fail:
 	if (rules->secmark) {
 		for (i = 0; i < size; i++)
-			kfree_sensitive(rules->secmark[i].label);
-		kfree_sensitive(rules->secmark);
+			kfree(rules->secmark[i].label);
+		kfree(rules->secmark);
 		rules->secmark_count = 0;
 		rules->secmark = NULL;
 	}
@@ -690,186 +657,6 @@
 	return false;
 }
 
-
-static bool verify_tags(struct aa_tags_struct *tags, const char **info)
-{
-	if ((tags->hdrs.size && !tags->hdrs.table) ||
-	    (!tags->hdrs.size && tags->hdrs.table)) {
-			*info = "failed verification tag.hdrs disagree";
-			return false;
-	}
-	if ((tags->sets.size && !tags->sets.table) ||
-	    (!tags->sets.size && tags->sets.table)) {
-			*info = "failed verification tag.sets disagree";
-			return false;
-	}
-	if ((tags->strs.size && !tags->strs.table) ||
-	    (tags->strs.size && !tags->strs.table)) {
-			*info = "failed verification tags->strs disagree";
-			return false;
-	}
-	/* no data present */
-	if (!tags->sets.size && !tags->hdrs.size && !tags->strs.size) {
-		return true;
-	} else if (!(tags->sets.size && tags->hdrs.size && tags->strs.size)) {
-		/* some data present but not all */
-		*info = "failed verification tags partial data present";
-		return false;
-	}
-
-	u32 i;
-	for (i = 0; i < tags->sets.size; i++) {
-		/* count followed by count indexes into hdrs */
-		u32 cnt = tags->sets.table[i];
-		if (i+cnt >= tags->sets.size) {
-			AA_DEBUG(DEBUG_UNPACK, "tagset too large %d+%d > sets.table[%d]", i, cnt, tags->sets.size);
-			*info = "failed verification tagset too large";
-			return false;
-		}
-		for (; cnt; cnt--) {
-			if (tags->sets.table[++i] >= tags->hdrs.size) {
-				AA_DEBUG(DEBUG_UNPACK, "tagsets idx out of bounds cnt %d sets.table[%d] >= %d", cnt, i-1, tags->hdrs.size);
-				*info = "failed verification tagsets idx out of bounds";
-				return false;
-			}
-		}
-	}
-	for (i = 0; i < tags->hdrs.size; i++) {
-		u32 idx = tags->hdrs.table[i].tags;
-		if (idx >= tags->strs.size) {
-			AA_DEBUG(DEBUG_UNPACK, "tag.hdrs idx oob idx %d > tags->strs.size=%d",
-				 idx, tags->strs.size);
-			*info = "failed verification tag.hdrs idx out of bounds";
-			return false;
-		}
-		if (tags->hdrs.table[i].count != tags->strs.table[idx].count) {
-			AA_DEBUG(DEBUG_UNPACK, "hdrs.table[%d].count=%d != tags->strs.table[%d]=%d",
-				 i, tags->hdrs.table[i].count, idx, tags->strs.table[idx].count);
-			*info = "failed verification tagd.hdrs[idx].count";
-			return false;
-		}
-		if (tags->hdrs.table[i].size != tags->strs.table[idx].size) {
-			AA_DEBUG(DEBUG_UNPACK, "hdrs.table[%d].size=%d != strs.table[%d].size=%d",
-				 i, tags->hdrs.table[i].size, idx, tags->strs.table[idx].size);
-			*info = "failed verification tagd.hdrs[idx].size";
-			return false;
-		}
-	}
-
-	return true;
-}
-
-static bool unpack_tagsets(struct aa_ext *e, struct aa_tags_struct *tags)
-{
-	u32 *sets;
-	u16 i, size;
-	void *pos = e->pos;
-
-	if (!aa_unpack_array(e, "sets", &size))
-		goto fail_reset;
-	sets = kcalloc(size, sizeof(u32), GFP_KERNEL);
-	if (!sets)
-		goto fail_reset;
-	for (i = 0; i < size; i++) {
-		if (!aa_unpack_u32(e, &sets[i], NULL))
-			goto fail;
-	}
-	if (!aa_unpack_nameX(e, AA_ARRAYEND, NULL))
-		goto fail;
-
-	tags->sets.size = size;
-	tags->sets.table = sets;
-
-	return true;
-
-fail:
-	kfree_sensitive(sets);
-fail_reset:
-	e->pos = pos;
-	return false;
-}
-
-static bool unpack_tag_header_ent(struct aa_ext *e, struct aa_tags_header *h)
-{
-	return aa_unpack_u32(e, &h->mask, NULL) &&
-		aa_unpack_u32(e, &h->count, NULL) &&
-		aa_unpack_u32(e, &h->size, NULL) &&
-		aa_unpack_u32(e, &h->tags, NULL);
-}
-
-static bool unpack_tag_headers(struct aa_ext *e, struct aa_tags_struct *tags)
-{
-	struct aa_tags_header *hdrs;
-	u16 i, size;
-	void *pos = e->pos;
-
-	if (!aa_unpack_array(e, "hdrs", &size))
-		goto fail_reset;
-	hdrs = kcalloc(size, sizeof(struct aa_tags_header), GFP_KERNEL);
-	if (!hdrs)
-		goto fail_reset;
-	for (i = 0; i < size; i++) {
-		if (!unpack_tag_header_ent(e, &hdrs[i]))
-			goto fail;
-	}
-	if (!aa_unpack_nameX(e, AA_ARRAYEND, NULL))
-		goto fail;
-
-	tags->hdrs.size = size;
-	tags->hdrs.table = hdrs;
-	AA_DEBUG(DEBUG_UNPACK, "headers %ld size %d", (long) hdrs, size);
-	return true;
-
-fail:
-	kfree_sensitive(hdrs);
-fail_reset:
-	e->pos = pos;
-	return false;
-}
-
-
-static size_t unpack_tags(struct aa_ext *e, struct aa_tags_struct *tags,
-	const char **info)
-{
-	void *pos = e->pos;
-
-	AA_BUG(!tags);
-	/* policy tags are optional */
-	if (aa_unpack_nameX(e, AA_STRUCT, "tags")) {
-		u32 version;
-
-		if (!aa_unpack_u32(e, &version, "version") || version != 1) {
-			*info = "invalid tags version";
-			goto fail_reset;
-		}
-		if (!unpack_strs_table(e, "strs", true, &tags->strs)) {
-			*info = "failed to unpack profile tag.strs";
-			goto fail;
-		}
-		if (!unpack_tag_headers(e, tags)) {
-			*info = "failed to unpack profile tag.headers";
-			goto fail;
-		}
-		if (!unpack_tagsets(e, tags)) {
-			*info = "failed to unpack profile tag.sets";
-			goto fail;
-		}
-		if (!aa_unpack_nameX(e, AA_STRUCTEND, NULL))
-			goto fail;
-
-		if (!verify_tags(tags, info))
-			goto fail;
-	}
-
-	return 0;
-
-fail:
-	aa_destroy_tags(tags);
-fail_reset:
-	e->pos = pos;
-	return -EPROTO;
-}
-
 static bool unpack_perm(struct aa_ext *e, u32 version, struct aa_perms *perm)
 {
 	u32 reserved;
@@ -1001,8 +788,7 @@
 		}
 	}
 
-	/* accept2 is in some cases being allocated, even with perms */
-	if (pdb->perms && !pdb->dfa->tables[YYTD_ID_ACCEPT2]) {
+	if (pdb->perms && version <= 2) {
 		/* add dfa flags table missing in v2 */
 		u32 noents = pdb->dfa->tables[YYTD_ID_ACCEPT]->td_lolen;
 		u16 tdflags = pdb->dfa->tables[YYTD_ID_ACCEPT]->td_flags;
@@ -1021,21 +807,16 @@
 	 * transition table may be present even when the dfa is
 	 * not. For compatibility reasons unpack and discard.
 	 */
-	if (!unpack_strs_table(e, "xtable", false, &pdb->trans) &&
-	    required_trans) {
+	if (!unpack_trans_table(e, &pdb->trans) && required_trans) {
 		*info = "failed to unpack profile transition table";
 		goto fail;
 	}
 
 	if (!pdb->dfa && pdb->trans.table)
-		aa_destroy_str_table(&pdb->trans);
+		aa_free_str_table(&pdb->trans);
 
-	/* TODO:
-	 * - move compat mapping here, requires dfa merging first
-	 * - move verify here, it has to be done after compat mappings
-	 * - move free of unneeded trans table here, has to be done
-	 *   after perm mapping.
-	 */
+	/* TODO: move compat mapping here, requires dfa merging first */
+	/* TODO: move verify here, it has to be done after compat mappings */
 out:
 	*policy = pdb;
 	return 0;
@@ -1158,7 +939,7 @@
 
 	/* optional */
 	(void) aa_unpack_u32(e, &profile->signal, "kill");
-	if (profile->signal < 1 || profile->signal > MAXMAPPED_SIG) {
+	if (profile->signal < 1 && profile->signal > MAXMAPPED_SIG) {
 		info = "profile kill.signal invalid value";
 		goto fail;
 	}
@@ -1333,7 +1114,6 @@
 		goto fail;
 	} else if (rules->file->dfa) {
 		if (!rules->file->perms) {
-			AA_DEBUG(DEBUG_UNPACK, "compat mapping perms");
 			error = aa_compat_map_file(rules->file);
 			if (error) {
 				info = "failed to remap file permission table";
@@ -1523,32 +1303,21 @@
 static bool verify_perms(struct aa_policydb *pdb)
 {
 	int i;
-	int xidx, xmax = -1;
 
 	for (i = 0; i < pdb->size; i++) {
 		if (!verify_perm(&pdb->perms[i]))
 			return false;
 		/* verify indexes into str table */
-		if ((pdb->perms[i].xindex & AA_X_TYPE_MASK) == AA_X_TABLE) {
-			xidx = pdb->perms[i].xindex & AA_X_INDEX_MASK;
-			if (xidx >= pdb->trans.size)
-				return false;
-			if (xmax < xidx)
-				xmax = xidx;
-		}
-		if (pdb->perms[i].tag && pdb->perms[i].tag >= pdb->tags.sets.size)
+		if ((pdb->perms[i].xindex & AA_X_TYPE_MASK) == AA_X_TABLE &&
+		    (pdb->perms[i].xindex & AA_X_INDEX_MASK) >= pdb->trans.size)
+			return false;
+		if (pdb->perms[i].tag && pdb->perms[i].tag >= pdb->trans.size)
 			return false;
 		if (pdb->perms[i].label &&
 		    pdb->perms[i].label >= pdb->trans.size)
 			return false;
 	}
-	/* deal with incorrectly constructed string tables */
-	if (xmax == -1) {
-		aa_destroy_str_table(&pdb->trans);
-	} else if (pdb->trans.size > xmax + 1) {
-		if (!aa_resize_str_table(&pdb->trans, xmax + 1, GFP_KERNEL))
-			return false;
-	}
+
 	return true;
 }
 
diff -u a/security/apparmor/policy_unpack_test.c b/security/apparmor/policy_unpack_test.c
--- a/security/apparmor/policy_unpack_test.c	2025-09-29 17:33:37.042574889 +0000
+++ b/security/apparmor/policy_unpack_test.c	2025-10-03 07:27:33.795849348 +0000
@@ -9,8 +9,6 @@
 #include "include/policy.h"
 #include "include/policy_unpack.h"
 
-#include <linux/unaligned.h>
-
 #define TEST_STRING_NAME "TEST_STRING"
 #define TEST_STRING_DATA "testing"
 #define TEST_STRING_BUF_OFFSET \
@@ -82,7 +80,7 @@
 	*(buf + 1) = strlen(TEST_U32_NAME) + 1;
 	strscpy(buf + 3, TEST_U32_NAME, e->end - (void *)(buf + 3));
 	*(buf + 3 + strlen(TEST_U32_NAME) + 1) = AA_U32;
-	put_unaligned_le32(TEST_U32_DATA, buf + 3 + strlen(TEST_U32_NAME) + 2);
+	*((__le32 *)(buf + 3 + strlen(TEST_U32_NAME) + 2)) = cpu_to_le32(TEST_U32_DATA);
 
 	buf = e->start + TEST_NAMED_U64_BUF_OFFSET;
 	*buf = AA_NAME;
@@ -105,7 +103,7 @@
 	*(buf + 1) = strlen(TEST_ARRAY_NAME) + 1;
 	strscpy(buf + 3, TEST_ARRAY_NAME, e->end - (void *)(buf + 3));
 	*(buf + 3 + strlen(TEST_ARRAY_NAME) + 1) = AA_ARRAY;
-	put_unaligned_le16(TEST_ARRAY_SIZE, buf + 3 + strlen(TEST_ARRAY_NAME) + 2);
+	*((__le16 *)(buf + 3 + strlen(TEST_ARRAY_NAME) + 2)) = cpu_to_le16(TEST_ARRAY_SIZE);
 
 	return e;
 }
diff -u a/security/apparmor/task.c b/security/apparmor/task.c
--- a/security/apparmor/task.c	2025-09-29 17:33:37.043574936 +0000
+++ b/security/apparmor/task.c	2025-10-03 07:27:33.795849348 +0000
@@ -15,7 +15,6 @@
 #include <linux/gfp.h>
 #include <linux/ptrace.h>
 
-#include "include/path.h"
 #include "include/audit.h"
 #include "include/cred.h"
 #include "include/policy.h"
@@ -301,33 +300,10 @@
 					    xrequest, &sa));
 }
 
-static const char* get_current_exe_path(char *buffer, int buffer_size)
-{
-	struct file *exe_file;
-	struct path p;
-	const char *path_str;
-
-	exe_file = get_task_exe_file(current);
-	if (!exe_file)
-		return ERR_PTR(-ENOENT);
-	p = exe_file->f_path;
-	path_get(&p);
-
-	if(aa_path_name(&p, FLAG_VIEW_SUBNS , buffer, &path_str, NULL, NULL))
-		return ERR_PTR(-ENOMEM);
-
-	fput(exe_file);
-	path_put(&p);
-
-	return path_str;
-}
-
 /* call back to audit ptrace fields */
 static void audit_ns_cb(struct audit_buffer *ab, void *va)
 {
 	struct apparmor_audit_data *ad = aad_of_va(va);
-	char *buffer;
-	const char *path;
 
 	if (ad->request & AA_USERNS_CREATE)
 		audit_log_format(ab, " requested=\"userns_create\"");
@@ -344,13 +320,6 @@
 		audit_log_untrustedstring(ab, ad->ns.target);
 	}
 
-	buffer = aa_get_buffer(false);
-	if(!buffer)
-		return; // OOM
-	path = get_current_exe_path(buffer, aa_g_path_max);
-	if (!IS_ERR(path))
-		audit_log_format(ab, " execpath=\"%s\"", path);
-	aa_put_buffer(buffer);
 }
 
 /*
